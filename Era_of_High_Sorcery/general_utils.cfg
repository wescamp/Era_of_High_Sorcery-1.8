#textdomain wesnoth-Era_of_High_Sorcery

#define OBSTRUCTING_TERRAINS
Mm^Xm,Md^Xm,Xu,Xv,Xos,*^Xo,_off^_usr,_s,_f#enddef

# WARNING: you can't use this macro unless [store_map_dimensions] has been called recently.
#define IS_REASONABLE_LOCATION
[and]
  x=1-$map_size.width
  y=1-$map_size.height
  [not]
    terrain={OBSTRUCTING_TERRAINS}
  [/not]
[/and]#enddef

#define MODIFY_DAMAGE_FOR_RESISTANCE_OF_HEX_INHABITANT_IF_ANY X Y DAMAGE_VAR TYPE
[store_unit]
  [filter]
    x={X}
    y={Y}
  [/filter]
  variable=dmfrohiia_unit
[/store_unit]
{IF_VAR dmfrohiia_unit.length equals 1 ([then]
  {VARIABLE_OP {DAMAGE_VAR} multiply $dmfrohiia_unit.resistance.{TYPE}}
  # "round to nearest"
  {IF_VAR dmfrohiia_unit.resistance.{TYPE} greater_than 100 ([then]
    # damage is increased - 0.5 rounds down
    {VARIABLE_OP {DAMAGE_VAR} add 49}
  [/then]
  [else]
    # damage is decreased - 0.5 rounds up
    {VARIABLE_OP {DAMAGE_VAR} add 50}
  [/else])}
  {VARIABLE_OP {DAMAGE_VAR} divide 100}
  {IF_VAR {DAMAGE_VAR} less_than_equal_to 0 ([then]
    {VARIABLE {DAMAGE_VAR} 1}
  [/then])}
[/then])}
#enddef

#define DAMAGE_HEX_NO_KILLING X Y DAMAGE
{VARIABLE damage_to_hex {DAMAGE}}
{IF_VAR damage_to_hex greater_than 0 ([then]
[if]
  [have_unit]
  x={X}
  y={Y}
  [/have_unit]
  [else] # else
    [store_locations]
      x={X}
      y={Y}
      variable=village_fixer
    [/store_locations]
    # note: sending [unit] to map redraws (bad - lets the player see a Boat)
    # note: to_variable + [unstore_unit] does not redraw (good - Boat is never seen)
    [unit]
      x={X}
      y={Y}
      side=1
      type=Boat
      role=eohs_proxy_to_take_damage_unit
      hitpoints=1
      max_hitpoints=1
      to_variable=dhnk_victim
    [/unit]
    [unstore_unit]
      variable=dhnk_victim
    [/unstore_unit]
    [capture_village]
      x={X}
      y={Y}
      side=$village_fixer.owner_side
    [/capture_village]
  [/else]
[/if]

[store_unit]
  [filter]
    x={X}
    y={Y}
  [/filter]
  variable=dhnk_victim
[/store_unit]
{VARIABLE dhnk_victim.resting false}
[if]
  [variable]
    name=dhnk_victim.variables.EoHS_special_immune_to_direct_damage
    boolean_equals=true
  [/variable]
  [not]
    [variable]
      name=ehs_override_allow_damage_to_leaders
      boolean_equals=true
    [/variable]
  [/not]

  [or]
    [variable]
      name=dhnk_victim.status.petrified
      boolean_equals=true
    [/variable]
  [/or]

  [or]
    [have_unit]
      x={X}
      y={Y}
      [filter_location]
        [not]
	  {NOT_IN_ANY_CIRCLE}
	[/not]
      [/filter_location]
    [/have_unit]
  [/or]

  [then]
    [unstore_unit]
      variable=dhnk_victim
      text=_"$damage_to_hex (blocked)"
      red,green,blue=128,128,255
    [/unstore_unit]
  [/then]
  [else]
    {VARIABLE_OP dhnk_victim.hitpoints add -$damage_to_hex}
    {VARIABLE bhm_x1 {X}}
    {VARIABLE bhm_y1 {Y}}
    {VARIABLE bhm_damage_inflicted $damage_to_hex}
    [set_variables]
      name=bhm_unit
      to_variable=dhnk_victim
    [/set_variables]
    [fire_event]
      name=been_hit_magically
    [/fire_event]
    [set_variables]
      name=dhnk_victim
      to_variable=bhm_unit
    [/set_variables]

    {IF_VAR dhnk_victim.hitpoints less_than 0 ([then]
      {VARIABLE dhnk_victim.hitpoints 0}
    [/then])}
    [unstore_unit]
      variable=dhnk_victim
      text=$damage_to_hex
      {COLOR_HARM}
    [/unstore_unit]
  [/else]
[/if]

{IF_VAR dhnk_victim.role equals eohs_proxy_to_take_damage_unit ([then]
  [kill]
    x={X}
    y={Y}
    animate=no
    fire_event=no
  [/kill]
[/then])}

{CLEAR_VARIABLE dhnk_victim}
[/then])}
{CLEAR_VARIABLE damage_to_hex}
#enddef

#define KILL_IF_NEEDED FILTER EXPERIENCE_GAINING_WIZARD_SIDE
[store_unit]
  [filter]
    side={EXPERIENCE_GAINING_WIZARD_SIDE}
    {IS_WIZARD_LEADER}
  [/filter]
  variable=xp_gaining_wizard
[/store_unit]

{EOHS_FULL_KILL xp_gaining_wizard ({FILTER}
[filter_wml]
  hitpoints=0
[/filter_wml]
) true true}
#enddef

#define CHASM_FALL_IF_NEEDED X Y KILLING_WIZARD_SIDE
[store_unit]
  [filter]
    x={X}
    y={Y}
    [filter_location]
      terrain=Ql,Qlf,Qxu
    [/filter_location]
  [/filter]
  variable=fissure_victim
[/store_unit]
{IF_VAR fissure_victim.length equals 1 ([then]
  {IF_VAR fissure_victim.movement_costs.unwalkable less_than_equal_to $fissure_victim.max_moves ([and]
    [variable]
      name=fissure_victim.movement_costs.unwalkable
      greater_than=0
    [/variable]
  [/and]
  [else] # else
    [sound]
      name=gryphon-shriek-1.ogg
    [/sound]
    [store_unit]
      [filter]
        side={KILLING_WIZARD_SIDE}
        {IS_WIZARD_LEADER}
      [/filter]
      variable=ehs_killing_unit
    [/store_unit]
    {EOHS_FULL_KILL ehs_killing_unit (x={X}
y={Y}) false false}
  [/else])}
[/then])}
#enddef
#define DROWN_IF_NEEDED X Y KILLING_WIZARD_SIDE
[store_unit]
  [filter]
    x={X}
    y={Y}
    [filter_location]
      terrain=Wo
    [/filter_location]
  [/filter]
  variable=drowning_victim
[/store_unit]
{IF_VAR drowning_victim.length equals 1 ([then]
  {IF_VAR drowning_victim.movement_costs.deep_water less_than_equal_to $fissure_victim.max_moves ([and]
    [variable]
      name=drowning_victim.movement_costs.deep_water
      greater_than=0
    [/variable]
  [/and]
  [else] # else
    [unstore_unit]
      variable=drowning_victim
      text=_"drowned"
      red,green,blue=0,0,255
    [/unstore_unit]
    [store_unit]
      [filter]
        side={KILLING_WIZARD_SIDE}
        {IS_WIZARD_LEADER}
      [/filter]
      variable=ehs_killing_unit
    [/store_unit]
    {EOHS_FULL_KILL ehs_killing_unit (x={X}
y={Y}) true false}
  [/else])}
[/then])}
#enddef

#define EOHS_FULL_KILL_STORE_BOTH VICTIM_FILTER
[store_unit]
  [filter]
    {VICTIM_FILTER}
    find_in=eohs_full_kill_victims
  [/filter]
  variable=eohs_full_kill_victims
[/store_unit]
{IF_VAR eohs_full_kill_killer.length greater_than 0 ([then]
  [store_unit]
    [filter]
      x=$eohs_full_kill_killer.x
      y=$eohs_full_kill_killer.y
    [/filter]
    variable=eohs_full_kill_killer
  [/store_unit]
[/then])}
#enddef
#define EOHS_FULL_KILL_LOAD_UNITS
[store_unit]
  [filter]
    x=$eohs_full_kill_victims[$efk_i].x
    y=$eohs_full_kill_victims[$efk_i].y
  [/filter]
  variable=unit
[/store_unit]
{IF_VAR eohs_full_kill_killer.length greater_than 0 ([then]
  [store_unit]
    [filter]
      x=$eohs_full_kill_killer.x
      y=$eohs_full_kill_killer.y
    [/filter]
    variable=second_unit
  [/store_unit]
[/then]
[else]
  {CLEAR_VARIABLE second_unit}
[/else])}

{IF_VAR second_unit.length greater_than 0 ([else] # else
  [store_unit]
    [filter]
      x=$eohs_full_kill_victims[$efk_i].x
      y=$eohs_full_kill_victims[$efk_i].y
    [/filter]
    variable=second_unit
  [/store_unit]
[/else])}
#enddef
#define EOHS_FULL_KILL KILLER_VAR VICTIM_FILTER ANIMATES GAINS_EXPERIENCE
{VARIABLE_OP eohs_full_kill_stored_x1 to_variable x1}
{VARIABLE_OP eohs_full_kill_stored_y1 to_variable y1}
{VARIABLE_OP eohs_full_kill_stored_x2 to_variable x2}
{VARIABLE_OP eohs_full_kill_stored_y2 to_variable y2}
[set_variables]
  name=eohs_full_kill_stored_unit
  to_variable=unit
[/set_variables]
[set_variables]
  name=eohs_full_kill_stored_second_unit
  to_variable=second_unit
[/set_variables]

{VARIABLE eohs_kill_animates {ANIMATES}}
{VARIABLE gains_experience {GAINS_EXPERIENCE}}

[store_unit]
  [filter]
    {VICTIM_FILTER}
  [/filter]
  variable=eohs_full_kill_victims
[/store_unit]
{IF_VAR {KILLER_VAR}.length greater_than 0 ([then]
  [store_unit]
    [filter]
      x=${KILLER_VAR}.x
      y=${KILLER_VAR}.y
    [/filter]
    variable=eohs_full_kill_killer
  [/store_unit]
[/then])}

{FOREACH eohs_full_kill_victims efk_i}
  {EOHS_FULL_KILL_LOAD_UNITS}
  {IF_VAR unit.length greater_than 0 ([then]
    [fire_event]
      name=last breath
      [primary_unit]
        x=$unit.x
        y=$unit.y
      [/primary_unit]
      [secondary_unit]
        x=$second_unit.x
        y=$second_unit.y
      [/secondary_unit]
    [/fire_event]
  [/then])}
{NEXT efk_i}

{EOHS_FULL_KILL_STORE_BOTH ({VICTIM_FILTER})}

{CLEAR_VARIABLE eohs_full_victims_animation_hack}

{IF_VAR eohs_kill_animates boolean_equals true ([then]
  {FOREACH eohs_full_kill_victims efk_i}
    [set_variables]
      name=eohs_full_victims_animation_hack
      mode=replace
      [value]
        [filter]
          x=$eohs_full_kill_victims[$efk_i].x
          y=$eohs_full_kill_victims[$efk_i].y
        [/filter]
        flag=death
	[insert_tag]
	  name=animate
	  variable=eohs_full_victims_animation_hack
	[/insert_tag]
      [/value]
    [/set_variables]
  {NEXT efk_i}

[insert_tag]
  name=animate_unit
  variable=eohs_full_victims_animation_hack
[/insert_tag]

[/then])}

{FOREACH eohs_full_kill_victims efk_i}
  [hide_unit]
    x=$eohs_full_kill_victims[$efk_i].x
    y=$eohs_full_kill_victims[$efk_i].y
  [/hide_unit]
{NEXT efk_i}

{FOREACH eohs_full_kill_victims efk_i}
  {EOHS_FULL_KILL_LOAD_UNITS}
  {IF_VAR unit.length greater_than 0 ([then]
    [fire_event]
      name=die
      [primary_unit]
        x=$unit.x
        y=$unit.y
      [/primary_unit]
      [secondary_unit]
        x=$second_unit.x
        y=$second_unit.y
      [/secondary_unit]
    [/fire_event]
  [/then])}
{NEXT efk_i}

{EOHS_FULL_KILL_STORE_BOTH ({VICTIM_FILTER})}

{FOREACH eohs_full_kill_victims efk_i}
  [kill]
    x=$eohs_full_kill_victims[$efk_i].x
    y=$eohs_full_kill_victims[$efk_i].y
    animate=no
    fire_event=no
  [/kill]
{NEXT efk_i}

{IF_VAR eohs_full_kill_killer.length greater_than 0 ([and]
  [variable]
    name=gains_experience
    boolean_equals=true
  [/variable]
[/and]
[then]
  {FOREACH eohs_full_kill_victims efk_i}
    {VARIABLE_OP eohs_full_kill_victims[$efk_i].level multiply 8}
    {IF_VAR eohs_full_kill_victims[$efk_i].level equals 0 ([then]
      {VARIABLE eohs_full_kill_victims[$efk_i].level 4}
    [/then])}
    {VARIABLE_OP eohs_full_kill_killer.experience add $eohs_full_kill_victims[$efk_i].level}
  {NEXT efk_i}
  [unstore_unit]
    variable=eohs_full_kill_killer
  [/unstore_unit]
[/then])}

[redraw]
[/redraw]

{VARIABLE_OP x1 to_variable eohs_full_kill_stored_x1}
{VARIABLE_OP y1 to_variable eohs_full_kill_stored_y1}
{VARIABLE_OP x2 to_variable eohs_full_kill_stored_x2}
{VARIABLE_OP y2 to_variable eohs_full_kill_stored_y2}
[set_variables]
  name=unit
  to_variable=eohs_full_kill_stored_unit
[/set_variables]
[set_variables]
  name=second_unit
  to_variable=eohs_full_kill_stored_second_unit
[/set_variables]
#enddef

#define DO_TO_EXPANDING_SERIES_OF_HEXES CENTER_X CENTER_Y MAX_RADIUS ACTIONS
{VARIABLE dtesoh_radius_iterator 0}
{VARIABLE dtesoh_radius_iterator_old -1}
[while]
  [variable]
    name=dtesoh_radius_iterator
    less_than_equal_to={MAX_RADIUS}
  [/variable]
  [do]
    {IF_VAR dtesoh_radius_iterator_old less_than 0 ([then]
      [store_locations]
        x=0
        y=0
        variable=dtesoh_location_pile
      [/store_locations]
    [/then]
    [else]
      [store_locations]
        {IS_REASONABLE_LOCATION}
        [and]
          x={CENTER_X}
          y={CENTER_Y}
          radius=$dtesoh_radius_iterator_old
	  [filter_radius]
            {IS_REASONABLE_LOCATION}
          [/filter_radius]
	[/and]
        variable=dtesoh_location_pile
      [/store_locations]
    [/else])}
    [store_locations]
      [not]
        find_in=dtesoh_location_pile
      [/not]
      {IS_REASONABLE_LOCATION}
      [and]
        x={CENTER_X}
        y={CENTER_Y}
        radius=$dtesoh_radius_iterator
	[filter_radius]
          {IS_REASONABLE_LOCATION}
        [/filter_radius]
      [/and]
      variable=dtesoh_location_pile
    [/store_locations]

    {FOREACH dtesoh_location_pile dtesoh_i}
      {VARIABLE x $dtesoh_location_pile[$dtesoh_i].x}
      {VARIABLE y $dtesoh_location_pile[$dtesoh_i].y}
      {VARIABLE terrain $dtesoh_location_pile[$dtesoh_i].terrain}
      {VARIABLE distance $dtesoh_radius_iterator}
      {ACTIONS}
    {NEXT dtesoh_i}
    {VARIABLE_OP dtesoh_radius_iterator add 1}
    {VARIABLE_OP dtesoh_radius_iterator_old add 1}
  [/do]
[/while]
#enddef

#define DAMAGE_HEX X Y DAMAGE EXPERIENCE_GAINING_WIZARD_SIDE
{DAMAGE_HEX_NO_KILLING ({X}) ({Y}) ({DAMAGE})}
{KILL_IF_NEEDED (x={X}
y={Y}) ({EXPERIENCE_GAINING_WIZARD_SIDE})}
#enddef


#define WHENEVER_DAMAGED VAR MACRO
[event]
name=attacker_hits
first_time_only=no
[filter_second]
  [filter_wml]
    [variables]
      {VAR}=true
    [/variables]
  [/filter_wml]
[/filter_second]
  [store_unit]
    [filter]
      x=$x2
      y=$y2
    [/filter]
    variable=damaged_unit
  [/store_unit]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=damaging_unit
  [/store_unit]
  {{MACRO} damage_inflicted}
[/event]

[event]
name=defender_hits
first_time_only=no
[filter]
  [filter_wml]
    [variables]
      {VAR}=true
    [/variables]
  [/filter_wml]
[/filter]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=damaged_unit
  [/store_unit]
  [store_unit]
    [filter]
      x=$x2
      y=$y2
    [/filter]
    variable=damaging_unit
  [/store_unit]
  {{MACRO} damage_inflicted}
[/event]

[event]
name=been_hit_magically
first_time_only=no
[if]
  [have_unit]
    x=$bhm_x1
    y=$bhm_y1
    [filter_wml]
      [variables]
        {VAR}=true
      [/variables]
    [/filter_wml]
  [/have_unit]
  [then]
    [set_variables]
      name=damaged_unit
      to_variable=bhm_unit
    [/set_variables]
    {CLEAR_VARIABLE damaging_unit}
    {{MACRO} bhm_damage_inflicted}
    [set_variables]
      name=bhm_unit
      to_variable=damaged_unit
    [/set_variables]
  [/then]
[/if]
[/event]
#enddef

#define APPLY_FOR_ALL_DIRECTIONS MACRO
{{MACRO} n}
{{MACRO} ne}
{{MACRO} se}
{{MACRO} s}
{{MACRO} sw}
{{MACRO} nw}
#enddef

#define EHS_OPPOSITE_DIRECTION_n
s#enddef
#define EHS_OPPOSITE_DIRECTION_ne
sw#enddef
#define EHS_OPPOSITE_DIRECTION_se
nw#enddef
#define EHS_OPPOSITE_DIRECTION_s
n#enddef
#define EHS_OPPOSITE_DIRECTION_sw
ne#enddef
#define EHS_OPPOSITE_DIRECTION_nw
se#enddef

#define EHS_CLOCKWISE_FROM_n
ne#enddef
#define EHS_CLOCKWISE_FROM_ne
se#enddef
#define EHS_CLOCKWISE_FROM_se
s#enddef
#define EHS_CLOCKWISE_FROM_s
sw#enddef
#define EHS_CLOCKWISE_FROM_sw
nw#enddef
#define EHS_CLOCKWISE_FROM_nw
n#enddef

#define EHS_COUNTERCLOCKWISE_FROM_n
nw#enddef
#define EHS_COUNTERCLOCKWISE_FROM_ne
n#enddef
#define EHS_COUNTERCLOCKWISE_FROM_se
ne#enddef
#define EHS_COUNTERCLOCKWISE_FROM_s
se#enddef
#define EHS_COUNTERCLOCKWISE_FROM_sw
s#enddef
#define EHS_COUNTERCLOCKWISE_FROM_nw
sw#enddef

#define GET_DIRECTION_TO_ADJACENT_HEX_AUX DIRECTION
[set_variables]
  name=ehs_gdtah_store_locations_array
  to_variable=ehs_gdtah_store_locations_array_template
[/set_variables]
{VARIABLE ehs_gdtah_store_locations_array.filter_adjacent_location.adjacent {DIRECTION}}
#[store_locations]
#  #HEX1_FILTER}
#  [filter_adjacent_location]
#    adjacent={DIRECTION}
#    #HEX2_FILTER}
#  [/filter_adjacent_location]
#  variable=this_direction_being_correct
#[/store_locations]
[insert_tag]
  name=store_locations
  variable=ehs_gdtah_store_locations_array
[/insert_tag]
{IF_VAR this_direction_being_correct.length greater_than 0 ([then]
  {VARIABLE $ehs_gdtah_varname {DIRECTION}}
[/then])}
#enddef

#define GET_DIRECTION_TO_ADJACENT_HEX VAR HEX1_FILTER HEX2_FILTER
{VARIABLE ehs_gdtah_varname {VAR}}
[set_variables]
  name=ehs_gdtah_store_locations_array_template
  [value]
    {HEX1_FILTER}
    [filter_adjacent_location]
      {HEX2_FILTER}
    [/filter_adjacent_location]
    variable=this_direction_being_correct
  [/value]
[/set_variables]
{APPLY_FOR_ALL_DIRECTIONS GET_DIRECTION_TO_ADJACENT_HEX_AUX}
#enddef

#define GET_CLOCKWISE_DIRECTION_AUX DIRECTION
{IF_VAR $ehs_gcd_original_direction_varname equals {DIRECTION} ([then]
  {VARIABLE $ehs_gcd_varname {EHS_CLOCKWISE_FROM_{DIRECTION}}}
[/then])}
#enddef
#define GET_CLOCKWISE_DIRECTION VAR ORIGINAL_DIRECTION_VAR
{VARIABLE ehs_gcd_varname {VAR}}
{VARIABLE ehs_gcd_original_direction_varname {ORIGINAL_DIRECTION_VAR}}
{APPLY_FOR_ALL_DIRECTIONS GET_CLOCKWISE_DIRECTION_AUX}
#enddef

#define GET_COUNTERCLOCKWISE_DIRECTION_AUX DIRECTION
{IF_VAR $ehs_gccd_original_direction_varname equals {DIRECTION} ([then]
  {VARIABLE $ehs_gccd_varname {EHS_COUNTERCLOCKWISE_FROM_{DIRECTION}}}
[/then])}
#enddef
#define GET_COUNTERCLOCKWISE_DIRECTION VAR ORIGINAL_DIRECTION_VAR
{VARIABLE ehs_gccd_varname {VAR}}
{VARIABLE ehs_gccd_original_direction_varname {ORIGINAL_DIRECTION_VAR}}
{APPLY_FOR_ALL_DIRECTIONS GET_COUNTERCLOCKWISE_DIRECTION_AUX}
#enddef

#define GET_OPPOSITE_DIRECTION_AUX DIRECTION
{IF_VAR $ehs_god_original_direction_varname equals {DIRECTION} ([then]
  {VARIABLE $ehs_god_varname {EHS_OPPOSITE_DIRECTION_{DIRECTION}}}
[/then])}
#enddef
#define GET_OPPOSITE_DIRECTION VAR ORIGINAL_DIRECTION_VAR
{VARIABLE ehs_god_varname {VAR}}
{VARIABLE ehs_god_original_direction_varname {ORIGINAL_DIRECTION_VAR}}
{APPLY_FOR_ALL_DIRECTIONS GET_OPPOSITE_DIRECTION_AUX}
#enddef


#define APPLY_FOR_ALL_SIDES MACRO
{{MACRO} 1}
{{MACRO} 2}
{{MACRO} 3}
{{MACRO} 4}
{{MACRO} 5}
{{MACRO} 6}
{{MACRO} 7}
{{MACRO} 8}
{{MACRO} 9}
{{MACRO} 10}
#enddef



#define EHS_SHORT_DELAY
    {VARIABLE ehs_short_delay_iter 0}

    ######### this "while" block says: wait a little while, redrawing every so often (gee, I hope they've made [delay] constantly redraw... TODO maybe change this if it turns out to - TODO make a FR asking for [delay] to get a boolean saying whether it should)
    [while]
      [variable]
        name=ehs_short_delay_iter
        less_than=3
      [/variable]
      [do]
        [delay]
          time=20
        [/delay]

        [redraw]
        [/redraw]

        {VARIABLE_OP ehs_short_delay_iter add 1}
      [/do]
    [/while]

    {CLEAR_VARIABLE ehs_short_delay_iter}
#enddef


