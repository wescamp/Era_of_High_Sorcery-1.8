#textdomain wesnoth-Era_of_High_Sorcery

#define energy_bolt_INFO_INIT
{BASE_SPELL_STATS energy_bolt attacks/magic-missile.png   evocation 1   5   3}
#enddef
#define energy_bolt_OPT_STRING
_"Energy Bolt ($energy_bolt_cost| gold)"#enddef
#define energy_bolt_DESCRIPTION
_"Inflicts 5 to 9 damage plus your Evocation level
upon one target within $energy_bolt_base_range| hexes."#enddef
#define energy_bolt_POSSIBLE_TARGETS
#enddef
#define energy_bolt_AUXILIARY_EVENTS
#enddef
#define energy_bolt_EFFECTS
[sound]
name=magic-missile-1.ogg
[/sound]
{RANDOM 5..9}
{VARIABLE energy_bolt_damage $random}
{VARIABLE_OP energy_bolt_damage add $evocation_skill_$side_number||}
{DAMAGE_HEX $x1 $y1 $energy_bolt_damage $side_number}
{CLEAR_VARIABLE energy_bolt_damage}
#enddef

#define wizard_sword_INFO_INIT
{BASE_SPELL_STATS wizard_sword attacks/sword-human.png   evocation 2   4   1}
{IS_ENCHANTMENT wizard_sword}
#enddef
#define wizard_sword_OPT_STRING
_"Wizard Sword ($wizard_sword_cost| gold)"#enddef
#define wizard_sword_DESCRIPTION
_"Grants a 7-3 magical sword to you or an adjacent unit.
The sword vanishes at the beginning of your third turn hence."#enddef
#define wizard_sword_POSSIBLE_TARGETS
[and]
  [filter]
  [/filter]
[/and]
#enddef
#define wizard_sword_EFFECTS
{VARIABLE will_disappear_on $turn_number}
{VARIABLE_OP will_disappear_on add 3}
[sound]
  name=throwing-knife-miss.ogg
[/sound]
[object]
  silent=yes
  [filter]
    x=$x1
    y=$y1
  [/filter]
  [effect]
    apply_to=new_attack
    description=_"wizard sword"
    icon=attacks/sword-human.png
    name=wizard_sword_$will_disappear_on
    range=melee
    type=blade
    damage=7
    number=3
    [specials]
      {WEAPON_SPECIAL_MAGICAL}
      [damage]
        id=disappears_dummy
	name=_"vanishes turn $will_disappear_on"
      [/damage]
    [/specials]
  [/effect]
[/object]
[unit_overlay]
  x=$x1
  y=$y1
  image=items/sword.png
[/unit_overlay]
#enddef
#define wizard_sword_AUXILIARY_EVENTS
[event]
name=side turn
first_time_only=no
  [store_unit]
    [filter]
      side=$side_number
      has_weapon=wizard_sword_$turn_number
    [/filter]
    variable=sword_losers
  [/store_unit]
  {FOREACH sword_losers wsae_i}
    [object]
      silent=yes
      [filter]
        x=$sword_losers[$wsae_i].x
        y=$sword_losers[$wsae_i].y
      [/filter]
      [effect]
        apply_to=remove_attacks
        name=wizard_sword_$turn_number
      [/effect]
    [/object]
    [remove_unit_overlay]
      x=$sword_losers[$wsae_i].x
      y=$sword_losers[$wsae_i].y
      image=items/sword.png
    [/remove_unit_overlay]
  {NEXT wsae_i}
[/event]
#enddef

#define mage_shield_INFO_INIT
{BASE_SPELL_STATS mage_shield attacks/rectangular-shield.png   evocation 3   4   1}
{IS_ENCHANTMENT mage_shield}
#enddef
#define mage_shield_OPT_STRING
_"Mage Shield ($mage_shield_cost| gold)"#enddef
#define mage_shield_DESCRIPTION
_"Surrounds yourself or an adjacent unit with a shield that
will block the first blow that hits it, then disappear."#enddef
#define mage_shield_POSSIBLE_TARGETS
[and]
  [filter]
    [not]
      [filter_wml]
        [variables]
	  mage_shield=true
	[/variables]
      [/filter_wml]
    [/not]
  [/filter]
[/and]
#enddef
#define mage_shield_EFFECTS
[sound]
  name=magic-holy-miss-2.ogg
[/sound]
{MODIFY_UNIT (x,y=$x1,$y1) variables.mage_shield true}
[unit_overlay]
  x=$x1
  y=$y1
  image=halo/saurian-magic-halo-3.png
[/unit_overlay]
#enddef
#define mage_shield_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.mage_shield false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=halo/saurian-magic-halo-3.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define MAGE_SHIELD_BLOCK DAMAGE_VAR
{mage_shield_END_ENCHANTMENT damaged_unit}
{IF_VAR damaging_unit.length equals 1 ([and]
  [variable]
    name=damaging_unit.variables.dispelling_touch
    boolean_equals=true
  [/variable]
[/and]
[else] # else
  [store_unit]
    [filter]
      x=$damaged_unit.x
      y=$damaged_unit.y
    [/filter]
    variable=damaged_unit
  [/store_unit]
  {VARIABLE amount_blocked ${DAMAGE_VAR}}
  {VARIABLE_OP damaged_unit.hitpoints add ${DAMAGE_VAR}}
  [unstore_unit]
    variable=damaged_unit
    text=_"$amount_blocked blocked!"
    red,green,blue=128,128,255
  [/unstore_unit]
  {VARIABLE {DAMAGE_VAR} 0}
[/else])}
#enddef
#define mage_shield_AUXILIARY_EVENTS
{WHENEVER_DAMAGED mage_shield MAGE_SHIELD_BLOCK}
#enddef

#define fire_ball_INFO_INIT
{BASE_SPELL_STATS fire_ball   attacks/fireball.png   evocation 6   16   3}
#enddef
#define fire_ball_OPT_STRING
_"Fire Ball ($fire_ball_cost| gold)"#enddef
#define fire_ball_DESCRIPTION
_"Inflicts 8 to 14 damage plus 1.5 times your
Evocation level upon every unit in a radius-1 area
around one target within $fire_ball_base_range| hexes."#enddef
#define fire_ball_POSSIBLE_TARGETS
#enddef
#define fire_ball_AUXILIARY_EVENTS
#enddef
#define fire_ball_EFFECTS
[sound]
name=explosion.ogg
[/sound]
[store_locations]
  [not]
    terrain={OBSTRUCTING_TERRAINS}
  [/not]
  [and]
    radius=1
    x=$x1
    y=$y1
  [/and]
  variable=victims
[/store_locations]
{FOREACH victims fire_ball_effects_i}
  {VARIABLE fbe_half_skill $evocation_skill_$side_number||}
  {VARIABLE_OP fbe_half_skill divide 2}
  {VARIABLE fbe_temp fbe_half_skill}
  {VARIABLE_OP fbe_temp multiply 2}
  {IF_VAR fbe_temp equals $evocation_skill_$side_number|| ([then]
    {RANDOM 8..14}
  [/then]
  [else]
    {RANDOM 8..15}
  [/else])}
  {VARIABLE fire_ball_damage $random}
  {VARIABLE_OP fire_ball_damage add $evocation_skill_$side_number||}
  {VARIABLE_OP fire_ball_damage add $fbe_half_skill}
  {DAMAGE_HEX_NO_KILLING $victims[$fire_ball_effects_i].x $victims[$fire_ball_effects_i].y $fire_ball_damage}
{NEXT fire_ball_effects_i}
{KILL_IF_NEEDED ([filter_location]
  radius=1
  x=$x1
  y=$y1
[/filter_location]) $side_number}
#FOREACH victims fire_ball_effects_i}
#  #KILL_IF_NEEDED $victims[$fire_ball_effects_i].x $victims[$fire_ball_effects_i].y $side_number}
#NEXT fire_ball_effects_i}
{CLEAR_VARIABLE victims}
{CLEAR_VARIABLE fire_ball_damage}
{CLEAR_VARIABLE fbe_temp}
{CLEAR_VARIABLE fbe_half_skill}
#enddef


### NOTE TO MAINTAINER: the "dispelled and ignored" effects necessitate specific exception code in the *dispelled* effect's spell description. Dark Pact is currently an exception because its events fire after dispelling touch's events, but that's a hack and should probably be cleaned up. The merely dispelled ones only require that there be a that_enchantment_END_ENCHANTMENT macro defined, which is usually relatively simple and/or needed already, and can be given an entry here:
#define APPLY_FOR_ALL_SIMPLY_DISPELLABLE_UNIT_ENCHANTMENTS MACRO
{{MACRO} dispelling_touch}
{{MACRO} mud_touch}
{{MACRO} eohs_regeneration}
{{MACRO} dark_pact}
#enddef

#define dispelling_touch_INFO_INIT
{BASE_SPELL_STATS dispelling_touch   attacks/touch-faerie.png   evocation 5   6   0}
{IS_ENCHANTMENT dispelling_touch}
#enddef
#define dispelling_touch_OPT_STRING
_"Dispelling Touch ($dispelling_touch_cost| gold)"#enddef
#define dispelling_touch_DESCRIPTION
_"Places an enchantment on you that will dispel the first enemy magic
that it comes into contact with. This uses up the enchantment.
The following types of enemy magic are affected when you hit a unit in melee
(if you hit a unit with more than one of these, all are affected):
Mud Touch, Regeneration, Dispelling Touch, Wraithform: dispelled
Mage Shield, Dark Pact: dispelled and ignored (i.e. the shield does not block anything)
Summoned creatures and undead: inflicts (skill*4) to (skill*6) damage
Also, if you end a turn on a poisoned hex, the poison is dispelled and ignored, without using up the dispelling touch."#enddef
#define dispelling_touch_POSSIBLE_TARGETS
[and]
  [filter]
    [not]
      [filter_wml]
        [variables]
	  dispelling_touch=true
	[/variables]
      [/filter_wml]
    [/not]
  [/filter]
[/and]
#enddef
#define DISPTOUCH_EFFECTS_AUX_AUX ENCHANTMENT_TYPE
{IF_VAR disptouch_victim.variables.{ENCHANTMENT_TYPE} boolean_equals true ([then]
  {VARIABLE disptouch_consumed true}
  {{ENCHANTMENT_TYPE}_END_ENCHANTMENT disptouch_victim}
[/then])}
#enddef
#define DISPTOUCH_EFFECTS_AUX XER XFILTER AFILTER XNUM YNUM
[event]
name={XER} hits
first_time_only=no
[{XFILTER}]
  [filter_wml]
    [variables]
      dispelling_touch=true
    [/variables]
  [/filter_wml]
[/{XFILTER}]
[{AFILTER}]
  range=melee
[/{AFILTER}]
  [store_unit]
    [filter]
      x=$x{XNUM}
      y=$y{XNUM}
    [/filter]
    variable=disptouch_user
  [/store_unit]
  [store_unit]
    [filter]
      x=$x{YNUM}
      y=$y{YNUM}
    [/filter]
    variable=disptouch_victim
  [/store_unit]
  {VARIABLE disptouch_consumed false}
  # wraithform is special (it has to be)
  {IF_VAR disptouch_victim.variables.wraithform boolean_equals true ([then]
    {VARIABLE disptouch_consumed true}
    {wraithform_END_ENCHANTMENT disptouch_victim}
  [/then]
  [else]
    {APPLY_FOR_ALL_SIMPLY_DISPELLABLE_UNIT_ENCHANTMENTS DISPTOUCH_EFFECTS_AUX_AUX}
    {IF_VAR disptouch_victim.variables.summoned boolean_equals true ([or]
      [variable]
        name=disptouch_victim.race
        equals=undead
      [/variable]
    [/or]
    [then]
      {VARIABLE disptouch_consumed true}
      {VARIABLE randmin $evocation_skill_$disptouch_user.side}
      {VARIABLE randmax $evocation_skill_$disptouch_user.side}
      {VARIABLE_OP randmin multiply 4}
      {VARIABLE_OP randmax multiply 6}
      {VARIABLE randstr $randmin|..$randmax}
      {RANDOM $randstr}
      {VARIABLE ehs_override_allow_damage_to_leaders true}
      {DAMAGE_HEX_NO_KILLING $disptouch_victim.x $disptouch_victim.y $random}
      {CLEAR_VARIABLE ehs_override_allow_damage_to_leaders}
    [/then])}
  [/else])}
  {IF_VAR disptouch_consumed boolean_equals true ([then]
    [sound]
      name=gunshot.wav
    [/sound]
    {dispelling_touch_END_ENCHANTMENT disptouch_user}
    {KILL_IF_NEEDED (x=$disptouch_victim.x
y=$disptouch_victim.y) $disptouch_user.side}
    #KILL_IF_NEEDED $disptouch_victim.x $disptouch_victim.y $disptouch_user.side}
  [/then])}
[/event]
#enddef
#define dispelling_touch_AUXILIARY_EVENTS
{DISPTOUCH_EFFECTS_AUX attacker filter        filter_attack        1 2}
{DISPTOUCH_EFFECTS_AUX defender filter_second filter_second_attack 2 1}
#enddef
#define dispelling_touch_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.dispelling_touch false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=halo/elven/ice-halo5.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define dispelling_touch_EFFECTS
[sound]
  name=magic-holy-2.ogg
[/sound]
[store_unit]
  [filter]
    x=$x1
    y=$y1
  [/filter]
  variable=disptouched
[/store_unit]
{VARIABLE disptouched.variables.dispelling_touch true}
[unstore_unit]
  variable=disptouched
[/unstore_unit]
[unit_overlay]
  x=$x1
  y=$y1
  image=halo/elven/ice-halo5.png
[/unit_overlay]
#enddef

#define corridor_of_frost_INFO_INIT
{BASE_SPELL_STATS corridor_of_frost attacks/iceball.png   evocation 4   8   1}
#enddef
#define corridor_of_frost_OPT_STRING
_"Corridor of Frost ($corridor_of_frost_cost| gold)"#enddef
#define corridor_of_frost_DESCRIPTION
_"Continues in the given direction for (your Evocation level) hexes,
slowing and inflicting 6 to 10 damage upon each unit in its path."#enddef
#define corridor_of_frost_POSSIBLE_TARGETS
[and]
  [filter_adjacent]
    [filter]
      side=$side_number
      {IS_WIZARD_LEADER}
    [/filter]
  [/filter_adjacent]
[/and]
#enddef
#define corridor_of_frost_AUXILIARY_EVENTS
#enddef
#define COF_EFFECTS DIRECTION
[store_locations]
  x=$x1
  y=$y1
  {NOT_IN_ANY_CIRCLE}
  [not]
    terrain={OBSTRUCTING_TERRAINS}
  [/not]
  [filter_adjacent_location]
    adjacent={DIRECTION}
    [filter]
      side=$side_number
      {IS_WIZARD_LEADER}
    [/filter]
  [/filter_adjacent_location]
  variable=next_victim
[/store_locations]
{IF_VAR next_victim.length equals 1 ([then]
  {VARIABLE num_frost_tiles $evocation_skill_$side_number||}
  #VARIABLE_OP num_frost_tiles add -2}
  [while]
    [variable]
      name=num_frost_tiles
      greater_than=0
    [/variable]
    [do]
      {VARIABLE_OP num_frost_tiles add -1}
      {VARIABLE this_x $next_victim.x}
      {VARIABLE this_y $next_victim.y}
      {RANDOM 6..10}
      [scroll_to]
        x=$this_x
        y=$this_y
        check_fogged=true
      [/scroll_to]

      [sound]
        name=magic-faeriefire.ogg
      [/sound]

      {DAMAGE_HEX $this_x $this_y $random $side_number}
      {EHS_SHORT_DELAY}
      [store_unit]
        [filter]
	  x=$this_x
	  y=$this_y
	[/filter]
	variable=this_victim
      [/store_unit]
      {IF_VAR this_victim.length equals 1 ([then]
        {VARIABLE this_victim.status.slowed true}
	[unstore_unit]
	  variable=this_victim
	  text=_"slowed"
	  {COLOR_HARM}
	[/unstore_unit]
      [/then])}
      [store_locations]
        [not]
          terrain={OBSTRUCTING_TERRAINS}
        [/not]
        [filter_adjacent_location]
          adjacent={DIRECTION}
          x=$this_x
	  y=$this_y
        [/filter_adjacent_location]
        variable=next_victim
      [/store_locations]
      {IF_VAR next_victim.length equals 0 ([then]
        {VARIABLE num_frost_tiles 0}
      [/then])}
    [/do]
  [/while]
[/then])}
{CLEAR_VARIABLE next_victim}
{CLEAR_VARIABLE this_x}
{CLEAR_VARIABLE this_y}
{CLEAR_VARIABLE this_victim}
#enddef
#define corridor_of_frost_EFFECTS
{COF_EFFECTS n}
{COF_EFFECTS ne}
{COF_EFFECTS se}
{COF_EFFECTS s}
{COF_EFFECTS sw}
{COF_EFFECTS nw}
#enddef


#define mass_teleport_INFO_INIT
{BASE_SPELL_STATS mass_teleport halo/teleport-7.png   evocation 7   22   6}
#enddef
#define mass_teleport_OPT_STRING
_"Gate ($mass_teleport_cost| gold)"#enddef
#define mass_teleport_DESCRIPTION
_"Teleports you and all adjacent units, friendly or enemy, to a target location within $mass_teleport_base_range| hexes.
Teleported units you control can move immediately, but can't attack.
You can't Gate to any location that would leave any of the units overlapping another unit,
nor inside a wall or void hex, nor - for non-flying units - over a chasm or lava.
Gate also cannot take you to locations that are completely inaccessible by non-magical means."#enddef
#define mass_teleport_AUXILIARY_EVENTS
[event]
name=ability_setup_extras
first_time_only=no
  {APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_TARGET_RESTRICTION_PREP}
[/event]
#enddef
#define MASS_TELEPORT_TARGET_RESTRICTION_PREP DIRECTION
[store_unit]
  [filter]
    [filter_adjacent]
      adjacent={EHS_OPPOSITE_DIRECTION_{DIRECTION}}
      side=$side_number
      {IS_WIZARD_LEADER}
    [/filter_adjacent]
    [filter_location]
      {NOT_IN_ANY_CIRCLE}
    [/filter_location]
  [/filter]
  variable=mttr_victim_{DIRECTION}
[/store_unit]
{IF_VAR mttr_victim_{DIRECTION}.length equals 0 ([then]
  {VARIABLE mttr_empty_hexes_needed_{DIRECTION} 0-1}
[/then]
[else]
  {VARIABLE mttr_empty_hexes_needed_{DIRECTION} 1}
  {IF_VAR mttr_victim_{DIRECTION}.movement_costs.unwalkable greater_than $mttr_victim_{DIRECTION}.max_moves ([then]
    {VARIABLE mttr_unacceptable_terrains_{DIRECTION} {OBSTRUCTING_TERRAINS},Qxu,Ql,Qlf}
  [/then]
  [else]
    {VARIABLE mttr_unacceptable_terrains_{DIRECTION} {OBSTRUCTING_TERRAINS}}
  [/else])}
[/else])}
#enddef
#define MASS_TELEPORT_TARGET_RESTRICTION DIRECTION
[and]
  [filter_adjacent_location]
    adjacent={DIRECTION}
    # no unit to be teleported to the target hex -> we're fine (since count is 0-1, we don't need to find any hexes)
    count=$mttr_empty_hexes_needed_{DIRECTION}
    [and]
      [not]
        terrain=$mttr_unacceptable_terrains_{DIRECTION}
      [/not]
    [/and]
    [and]
      # no unit on the target hex in that direction -> we're fine
      [not]
        [filter]
        [/filter]
      [/not]
      # the target hex is one of the ones to be teleported from anyway -> we're fine
      [or]
        [filter]
          side=$side_number
          {IS_WIZARD_LEADER}
        [/filter]
        radius=1
      [/or]
    [/and]
  [/filter_adjacent_location]
[/and]
#enddef
#define mass_teleport_POSSIBLE_TARGETS
[and]
      [not]
        terrain={OBSTRUCTING_TERRAINS}
      [/not]
[/and]
[and]
  # no unit on the target hex -> we're fine
  [not]
    [filter]
    [/filter]
  [/not]
  # the target hex is one of the ones to be teleported from anyway -> we're fine
  # (but don't allow teleporting to the same location, ha ha)
  [or]
    [filter_adjacent_location]
      [filter]
        side=$side_number
        {IS_WIZARD_LEADER}
      [/filter]
    [/filter_adjacent_location]
  [/or]
[/and]
{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_TARGET_RESTRICTION}
#enddef
#define MASS_TELEPORT_STORE_UNIT DIRECTION
[store_unit]
  [filter]
    [filter_adjacent]
      adjacent={DIRECTION}
      side=$side_number
      {IS_WIZARD_LEADER}
    [/filter_adjacent]
  [/filter]
  kill=yes
  variable=mte_victim_{DIRECTION}
[/store_unit]
#enddef
#define MASS_TELEPORT_MOVE_UNIT DIRECTION
{IF_VAR mte_victim_{DIRECTION}.length greater_than 0 ([then]
  [store_locations]
    [filter_adjacent_location]
      adjacent={DIRECTION}
      x=$x1
      y=$y1
    [/filter_adjacent_location]
    variable=mte_target_{DIRECTION}
  [/store_locations]
  {VARIABLE mte_victim_{DIRECTION}.x $mte_target_{DIRECTION}.x}
  {VARIABLE mte_victim_{DIRECTION}.y $mte_target_{DIRECTION}.y}
  {VARIABLE mte_victim_{DIRECTION}.attacks_left 0}
[/then])}
#enddef
#define MASS_TELEPORT_DROP_UNIT DIRECTION
{IF_VAR mte_victim_{DIRECTION}.length greater_than 0 ([then]
  [unstore_unit]
    variable=mte_victim_{DIRECTION}
    text=_"teleported"
    red,green,blue=255,255,255
  [/unstore_unit]
  [capture_village]
    x=$mte_victim_{DIRECTION}.x
    y=$mte_victim_{DIRECTION}.y
    side=$mte_victim_{DIRECTION}.side
  [/capture_village]
  [fire_event]
    name=moveto
    [primary_unit]
      x=$mte_victim_{DIRECTION}.x
      y=$mte_victim_{DIRECTION}.y
    [/primary_unit]
  [/fire_event]
[/then])}
#enddef
#define mass_teleport_EFFECTS
{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_STORE_UNIT}
{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_MOVE_UNIT}
[store_unit]
  [filter]
    side=$side_number
    {IS_WIZARD_LEADER}
  [/filter]
  kill=yes
  variable=current_leader_info
[/store_unit]
[redraw]
[/redraw]
{VARIABLE current_leader_info.x $x1}
{VARIABLE current_leader_info.y $y1}
{VARIABLE current_leader_info.attacks_left 0}
[unstore_unit]
  variable=current_leader_info
  text=_"teleport"
  red,green,blue=255,255,255
[/unstore_unit]
[capture_village]
  x=$x1
  y=$y1
  side=$side_number
[/capture_village]
[fire_event]
  name=moveto
  [primary_unit]
    x=$x1
    y=$y1
  [/primary_unit]
[/fire_event]

{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_DROP_UNIT}
#enddef


#define ogrify_INFO_INIT
{BASE_SPELL_STATS ogrify units/ogres/ogre-attack3.png   evocation 8   21   1}
#enddef
#define ogrify_OPT_STRING
_"Aberrant Growth ($ogrify_cost| gold)"#enddef
#define ogrify_DESCRIPTION
_"Transforms one adjacent non-leader elf, dwarf, human, goblin,
or orc into a huge Ogre. The ogre retains its experience and
will have the same fraction of its hitpoints remaining as did
the original unit, but is otherwise a completely new unit.
If a level 0 unit is hit with this spell, it will merely become
a Young Ogre.
Note that in you can replace an enemy unit with an ogre just
as well as your own units, but it will remain your enemy."#enddef
#define ogrify_POSSIBLE_TARGETS
[and]
  [filter]
    [not]
      {IS_WIZARD_LEADER}
    [/not]
    [and]
      race=elf
      [or]
        race=dwarf
      [/or]
      [or]
        race=human
      [/or]
      [or]
        race=goblin
      [/or]
      [or]
        race=orc
      [/or]
    [/and]
  [/filter]
[/and]
#enddef
#define ogrify_AUXILIARY_EVENTS
#enddef
#define ogrify_EFFECTS
[sound]
  name=ogre-hit-1.ogg
[/sound]
[store_unit]
  [filter]
    x=$x1
    y=$y1
  [/filter]
  variable=ogrify_victim
[/store_unit]
{IF_VAR ogrify_victim.level equals 0 ([then]
  {VARIABLE ogrify_victim_type (Young Ogre)}
[/then]
[else]
  {VARIABLE ogrify_victim_type (Ogre)}
[/else])}
{EOHS_FULL_KILL mudtouch_user (x=$ogrify_victim.x
y=$ogrify_victim.y) false false}
[unit]
  to_variable=ogrify_result
  side=$ogrify_victim.side
  type=$ogrify_victim_type
  x=$ogrify_victim.x
  y=$ogrify_victim.y
  experience=$ogrify_victim.experience
  moves=0
  attacks_left=0
[/unit]
{VARIABLE_OP ogrify_result.hitpoints multiply $ogrify_victim.hitpoints}
{VARIABLE_OP ogrify_result.hitpoints divide $ogrify_victim.max_hitpoints}
[unstore_unit]
  variable=ogrify_result
  text=_"Transmogrified!"
  red,green,blue=255,208,135
[/unstore_unit]
{CHASM_FALL_IF_NEEDED $ogrify_victim.x $ogrify_victim.y $side_number}
#enddef


#define circle_of_protection_INFO_INIT
{BASE_SPELL_STATS circle_of_protection   attacks/staff-elven.png   evocation 9   18   1}
#enddef
#define circle_of_protection_OPT_STRING
_"Circle of Protection ($circle_of_protection_cost| gold)"#enddef
#define circle_of_protection_DESCRIPTION
_"Places a circle of protection at your location or at an adjacent target hex.
Units in circles of protection cannot be targetted - or affected in any way - by enemy spells,
and the circles protect against the potentially harmful affects of friendly spells as well.
If a unit is attacked while in a circle of protection, both sides will do 1/3 the normal damage.
There is no limit to how long a circle of protection lasts, but it disappears if an enemy enters it."#enddef
#define circle_of_protection_POSSIBLE_TARGETS
{NOT_IN_ANY_CIRCLE}
#enddef
#define CLEAR_COP_LIST SIDE
{VARIABLE circles_of_protection_x_list_{SIDE} 0}
{VARIABLE circles_of_protection_y_list_{SIDE} 0}
#enddef
#define DISPEL_COP X Y SIDE
[removeitem]
  x={X}
  y={Y}
  image=scenery/circle-magic-glow.png
[/removeitem]
[removeitem]
  x={X}
  y={Y}
  image=flags/flag-icon.png~TC({SIDE},flag_green)
[/removeitem]
[store_locations]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
  [not]
    x={X}
    y={Y}
  [/not]
  variable=remaining_circles
[/store_locations]
[set_variable]
  name=circles_of_protection_x_list_{SIDE}
  [join]
    variable=remaining_circles
    key=x
    separator=,
  [/join]
[/set_variable]
[set_variable]
  name=circles_of_protection_y_list_{SIDE}
  [join]
    variable=remaining_circles
    key=y
    separator=,
  [/join]
[/set_variable]
#enddef
#define COP_STEPPING_EVENT SIDE
[event]
name=moveto
first_time_only=no
[filter]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
  # rule out as much as possible via filter, to avoid breaking undo
  [not]
    side={SIDE}
  [/not]
  [not]
    [filter_wml]
      team_name=$circle_of_protection_controller_$x1|_$y1
    [/filter_wml]
  [/not]
[/filter]
  [store_side]
    side=$side_number
    variable=stepper_side
  [/store_side]
  {IF_VAR stepper_side.team_name not_equals $circle_of_protection_controller_$x1|_$y1 ([then]
    {DISPEL_COP $x1 $y1 {SIDE}}
  [/then])}
[/event]
#enddef
#define COP_ATTACK_EVENT SIDE
[event]
name=attack
first_time_only=no
[filter_second]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
[/filter_second]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=attacker
  [/store_unit]
  {IF_VAR attacker.variables.dispelling_touch boolean_equals true ([then]
    {DISPEL_COP $x2 $y2 {SIDE}}
    [sound]
      name=gunshot.wav
    [/sound]
    {dispelling_touch_END_ENCHANTMENT attacker}
  [/then]
  [else]
    [object]
      silent=yes
      [filter]
        x=$x1
        y=$y1
      [/filter]
      [effect]
        apply_to=attack
        [set_specials]
          mode=append
          [damage]
            id=cop_damage_reduce
            multiply=0.34
            apply_to=both
          [/damage]
        [/set_specials]
      [/effect]
    [/object]
  [/else])}
[/event]
[event]
name=attack end
first_time_only=no
[filter_second]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
[/filter_second]
  [object]
    silent=yes
    [filter]
      x=$x1
      y=$y1
    [/filter]
    [effect]
      apply_to=attack
      remove_specials=cop_damage_reduce
    [/effect]
  [/object]
[/event]
#enddef
#define circle_of_protection_AUXILIARY_EVENTS
[event]
name=prestart
  {APPLY_FOR_ALL_SIDES CLEAR_COP_LIST}
[/event]
{APPLY_FOR_ALL_SIDES COP_STEPPING_EVENT}
{APPLY_FOR_ALL_SIDES COP_ATTACK_EVENT}
#enddef
#define circle_of_protection_EFFECTS
[sound]
  name=magic-holy-miss-2.ogg
[/sound]
[store_side]
  side=$side_number
  variable=caster_side
[/store_side]
{VARIABLE circle_of_protection_controller_$x1|_$y1 $current_side_info.team_name}
{VARIABLE circles_of_protection_x_list_$side_number $circles_of_protection_x_list_$side_number||,$x1}
{VARIABLE circles_of_protection_y_list_$side_number $circles_of_protection_y_list_$side_number||,$y1}
[item]
  x=$x1
  y=$y1
  halo=scenery/circle-magic-glow.png
[/item]
[item]
  x=$x1
  y=$y1
  image=flags/flag-icon.png~TC($side_number|,flag_green)
[/item]
#enddef



#define meteor_storm_INFO_INIT
{BASE_SPELL_STATS meteor_storm   attacks/curse.png   evocation 13   68   12}
#enddef
#define meteor_storm_OPT_STRING
_"Meteor Storm ($meteor_storm_cost| gold)"#enddef
#define meteor_storm_DESCRIPTION
_"Drops 10 to 13 flaming boulders near one target within $meteor_storm_base_range| hexes.
Units and terrain in the area will be severly damaged, including destruction of villages and keeps."#enddef
#define meteor_storm_POSSIBLE_TARGETS
#enddef
#define meteor_storm_AUXILIARY_EVENTS
#enddef
#define METEOR_TERRAIN_MOD DAMAGE_COST SRC_TYPES DST_TYPE LAYER EXTRA_STUFF
{IF_VAR meteor_damage greater_than_equal_to {DAMAGE_COST} ([and]
  [have_location]
    x=$x
    y=$y
    terrain={SRC_TYPES}
  [/have_location]
[/and]
[then]
  [terrain]
    x=$x
    y=$y
    layer={LAYER}
    terrain={DST_TYPE}
  [/terrain]
  {VARIABLE_OP meteor_damage add -{DAMAGE_COST}}
  {EXTRA_STUFF}
[/then])}
#enddef
#define meteor_storm_EFFECTS
{RANDOM 10..13}
{VARIABLE boulders_left $random}
[store_locations]
  [not]
    terrain={OBSTRUCTING_TERRAINS}
  [/not]
  [and]
    x=$x1
    y=$y1
    radius=6
    [filter_radius]
      [not]
        terrain={OBSTRUCTING_TERRAINS}
      [/not]
    [/filter_radius]
  [/and]
  variable=possible_targets
[/store_locations]
[store_locations]
  [not]
    terrain={OBSTRUCTING_TERRAINS}
  [/not]
  [and]
    x=$x1
    y=$y1
    radius=4
    [filter_radius]
      [not]
        terrain={OBSTRUCTING_TERRAINS}
      [/not]
    [/filter_radius]
  [/and]
  variable=preferred_targets
[/store_locations]

[while]
  [variable]
    name=boulders_left
    greater_than=0
  [/variable]
  [do]
    {RANDOM 1..3}
    {IF_VAR random equals 1 ([then]
      {RANDOM 1..$possible_targets.length}
      {VARIABLE center_x $possible_targets[$random].x}
      {VARIABLE center_y $possible_targets[$random].y}
    [/then]
    [else]
      {RANDOM 1..$preferred_targets.length}
      {VARIABLE center_x $preferred_targets[$random].x}
      {VARIABLE center_y $preferred_targets[$random].y}
    [/else])}
    {RANDOM explosion.ogg,dragonstick.ogg}
    [sound]
      name=$random
    [/sound]
    {DO_TO_EXPANDING_SERIES_OF_HEXES $center_x $center_y 2 (
      {RANDOM 14..36}
      {VARIABLE meteor_damage $random}
      {VARIABLE_OP meteor_damage add $evocation_skill_$side_number||}
      {VARIABLE_OP meteor_damage add $evocation_skill_$side_number||}
      {VARIABLE_OP distance add 1}
      {VARIABLE_OP meteor_damage divide $distance}
      {DAMAGE_HEX_NO_KILLING $x $y $meteor_damage}

      [if]
      [have_location]
        x=$x
        y=$y
        {NOT_IN_ANY_CIRCLE}
      [/have_location]
      [then]

      {METEOR_TERRAIN_MOD -2 *^Gvs Gg overlay ()}
      {METEOR_TERRAIN_MOD 5 "*^Bw/,*^Bw\,*^Bw|" Ww overlay ([sound]
  name=cave-in.ogg
[/sound])}

      {METEOR_TERRAIN_MOD 10 Ai^*  Ww  base ()}
      {METEOR_TERRAIN_MOD 15 Aa^*  Gg  base ()}

      {METEOR_TERRAIN_MOD 25 Ce^*  Re  base ()}
      {METEOR_TERRAIN_MOD 30 Ke^*  Re  base ()}
      {METEOR_TERRAIN_MOD 20 Ch^*  Chr base ()}
      {METEOR_TERRAIN_MOD 25 Kh^*  Khr base ()}
      {METEOR_TERRAIN_MOD 25 Cv^*  Chr base ()}
      {METEOR_TERRAIN_MOD 30 Kv^*  Khr base ()}
      {METEOR_TERRAIN_MOD 30 Cud^* Chr base ()}
      {METEOR_TERRAIN_MOD 35 Kud^* Khr base ()}

      {METEOR_TERRAIN_MOD 20 "Chr^*,Chw^*,Chs^*" Dd^Dr both ()}
      {METEOR_TERRAIN_MOD 25 "Khr^*,Khw^*,Khs^*" Dd^Dr both ()}

      {METEOR_TERRAIN_MOD 15 Ww^V^* Ww both ()}
      {METEOR_TERRAIN_MOD 20 "*^V*,*^F*,Gg^Wm" "^Dr" (overlay) ([sound]
  name=ambient/campfire.ogg
[/sound])}
      {METEOR_TERRAIN_MOD 10 "*^Uf,*^Ufi" "^Dr" (overlay) ()}
      {METEOR_TERRAIN_MOD 10 "*^Ufi" "^Ii" (overlay) ()}

      {METEOR_TERRAIN_MOD 15 "*^Do" Ds overlay ()}
      {METEOR_TERRAIN_MOD 5 Dd^* Ds base ()}
      {METEOR_TERRAIN_MOD 10 "Re^*,Rd^*,Rr^*,Rp^*,Ur^*" Ds base ()}
      {METEOR_TERRAIN_MOD 18 "Gg^*,Ggf^*,Gs^*" Ds base ()}
      {METEOR_TERRAIN_MOD 15 Wwr^* Ww base ()}
      {METEOR_TERRAIN_MOD 20 Wwf^* Ww base ()}
      {METEOR_TERRAIN_MOD 20 Ss^* Ds base ()}
      {METEOR_TERRAIN_MOD 12 Ha^* Hh base ()}
      {METEOR_TERRAIN_MOD 12 Hh^* Hd base ()}
      {METEOR_TERRAIN_MOD 12 Ms^* Mm base ()}
      {METEOR_TERRAIN_MOD 35 Mm^* Md base ()}
      {METEOR_TERRAIN_MOD 46 Md^* Hd base ()}
      {METEOR_TERRAIN_MOD 25 Hd^* Dd^Dr both ()}

      {METEOR_TERRAIN_MOD 0 Ds^Dr Dd^Dr both ()}

      {METEOR_TERRAIN_MOD 30 Ww^* Wo base ()}

      {METEOR_TERRAIN_MOD 40 Ds Dd^Dc both ()}
      {METEOR_TERRAIN_MOD 45 Dd^Dr Dd^Dc both ()}
      {RANDOM 1..3}
      {IF_VAR random equals 1 ([then]
        {METEOR_TERRAIN_MOD 50 Qlf^* Ql base ()}
        {METEOR_TERRAIN_MOD 55 Dd^Dc,Uu^*,Uh^*,Wo^* Qxu both ()}
        {CHASM_FALL_IF_NEEDED $x $y $side_number}
      [/then])}

      [/then]
      [/if]
    )}
    {RANDOM 1..3}
    {IF_VAR random equals 1 ([then]
      {EHS_SHORT_DELAY}
      {EHS_SHORT_DELAY}
      {EHS_SHORT_DELAY}
    [/then])}
    [redraw]
    [/redraw]
    {KILL_IF_NEEDED ([filter_location]
  x=$x1
  y=$y1
  radius=2
  [filter_radius]
    [not]
      terrain={OBSTRUCTING_TERRAINS}
    [/not]
  [/filter_radius]
[/filter_location]) $side_number}
    {VARIABLE_OP boulders_left add -1}
  [/do]
[/while]
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{RANDOM 1..3}
[sound]
  name=ambient/birds$random|.ogg
[/sound]
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{RANDOM 1..3}
[sound]
  name=ambient/birds$random|.ogg
[/sound]
#enddef


