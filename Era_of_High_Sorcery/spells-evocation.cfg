#textdomain wesnoth-Era_of_High_Sorcery

#define energy_bolt_INFO_INIT
{BASE_SPELL_STATS energy_bolt attacks/magic-missile.png   evocation 1   5   3}
#enddef
#define energy_bolt_NAME
_"Energy Bolt"#enddef
#define energy_bolt_DESCRIPTION
_"Inflicts 5 to 9 damage plus your Evocation level
upon one target within $energy_bolt_base_range| hexes."#enddef
#define energy_bolt_CHECK_TARGET
#enddef
#define energy_bolt_AUXILIARY_EVENTS
#enddef
#define energy_bolt_EFFECTS
[sound]
name=magic-missile-1.ogg
[/sound]
{RANDOM 5..9}
{VARIABLE energy_bolt_damage $random}
{VARIABLE_OP energy_bolt_damage add $evocation_skill_$side_number||}
{DAMAGE_HEX $x1 $y1 $energy_bolt_damage $side_number}
{CLEAR_VARIABLE energy_bolt_damage}
#enddef

#define wizard_sword_INFO_INIT
{BASE_SPELL_STATS wizard_sword attacks/sword-human.png   evocation 2   4   1}
{IS_ENCHANTMENT wizard_sword}
#enddef
#define wizard_sword_NAME
_"Wizard Sword"#enddef
#define wizard_sword_DESCRIPTION
_"Grants a 7-3 magical sword to you or an adjacent unit.
The sword vanishes at the beginning of your third turn hence."#enddef
#define wizard_sword_CHECK_TARGET
#enddef
#define wizard_sword_EFFECTS
{VARIABLE will_disappear_on $turn_number}
{VARIABLE_OP will_disappear_on add 3}
[sound]
  name=throwing-knife-miss.ogg
[/sound]
[object]
  silent=yes
  [filter]
    x=$x1
    y=$y1
  [/filter]
  [effect]
    apply_to=new_attack
    description=_"wizard sword"
    icon=attacks/sword-human.png
    name=eohs_wizard_sword
    range=melee
    type=blade
    damage=7
    number=3
    [specials]
      {WEAPON_SPECIAL_MAGICAL}
      [damage]
        id=$will_disappear_on|_disappears_dummy
	name=_"vanishes turn $will_disappear_on"
      [/damage]
    [/specials]
  [/effect]
[/object]
[unit_overlay]
  x=$x1
  y=$y1
  image=items/sword.png
[/unit_overlay]
{UPDATE_DUMMY_ATTACK_SPECIALS $x1 $y1}
#enddef
#define wizard_sword_AUXILIARY_EVENTS
[event]
name=side turn
first_time_only=no
  [store_unit]
    [filter]
      side=$side_number
      has_weapon=eohs_wizard_sword
    [/filter]
    variable=sword_losers
  [/store_unit]
  {FOREACH sword_losers wsae_i}
    {VARIABLE all_wizard_swords_gone mu}
    {FOREACH sword_losers[$wsae_i].attack wsae_j}
      {IF_VAR sword_losers[$wsae_i].attack[$wsae_j].name equals eohs_wizard_sword ([then]
        [set_variables]
          name=special_name_info
          [split]
            list=$sword_losers[$wsae_i].attack[$wsae_j].specials.damage.id
            key=turn_to_remove_on
            separator="_"
          [/split]
        [/set_variables]
        {IF_VAR special_name_info.turn_to_remove_on less_than_equal_to $turn_number ([then]
          [object]
            silent=yes
            [filter]
              x=$sword_losers[$wsae_i].x
              y=$sword_losers[$wsae_i].y
            [/filter]
            [effect]
              apply_to=remove_attacks
              special=$sword_losers[$wsae_i].attack[$wsae_j].specials.damage.id
            [/effect]
          [/object]
          {IF_VAR all_wizard_swords_gone equals mu ([then]
            {VARIABLE all_wizard_swords_gone true}
          [/then])}
        [/then]
        [else]
          {VARIABLE all_wizard_swords_gone false}
        [/else])}
      [/then])}
    {NEXT wsae_j}
    {IF_VAR all_wizard_swords_gone equals true ([then]
      [remove_unit_overlay]
        x=$sword_losers[$wsae_i].x
        y=$sword_losers[$wsae_i].y
        image=items/sword.png
      [/remove_unit_overlay]
    [/then])}
  {NEXT wsae_i}
[/event]
#enddef

#define mage_shield_INFO_INIT
{BASE_SPELL_STATS mage_shield attacks/rectangular-shield.png   evocation 3   4   1}
{IS_ENCHANTMENT mage_shield}
#enddef
#define mage_shield_NAME
_"Mage Shield"#enddef
#define mage_shield_DESCRIPTION
_"Surrounds yourself or an adjacent unit with a crude magical shield that
will block the damage of first blow that hits it, then disappear.
(Only damage is blocked; other effects happen as normal.)"#enddef
#define mage_shield_CHECK_TARGET
{CANT_CAST_IF_ALREADY_ENCHANTED_WITH mage_shield _"You can't cast a Mage Shield on a unit that already has one."}
#enddef
#define mage_shield_EFFECTS
[sound]
  name=magic-holy-miss-2.ogg
[/sound]
{MODIFY_UNIT (x,y=$x1,$y1) variables.mage_shield true}
{GIVE_DUMMY_ABILITY_FOR_ENCHANTMENT (x,y=$x1,$y1) mage_shield _"male^shielded" _"female^shielded" _"Shielded:

This unit is surrounded by a magical shield that will nullify the damage of the first hit to land on it. The shield will disappear after blocking one hit."}
[unit_overlay]
  x=$x1
  y=$y1
  image=halo/saurian-magic-halo-3.png
[/unit_overlay]
#enddef
#define mage_shield_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.mage_shield false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
{REMOVE_DUMMY_ABILITY_FOR_ENCHANTMENT (x,y=${VAR}.x|,${VAR}.y|) mage_shield}
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=halo/saurian-magic-halo-3.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define MAGE_SHIELD_BLOCK DAMAGE_VAR
{mage_shield_END_ENCHANTMENT damaged_unit}
{IF_VAR damaging_unit.length equals 1 ([and]
  [variable]
    name=damaging_unit.variables.dispelling_touch
    boolean_equals=true
  [/variable]
[/and]
[else] # else
  [store_unit]
    [filter]
      x=$damaged_unit.x
      y=$damaged_unit.y
    [/filter]
    variable=damaged_unit
  [/store_unit]
  {VARIABLE amount_blocked ${DAMAGE_VAR}}
  {VARIABLE_OP damaged_unit.hitpoints add ${DAMAGE_VAR}}
  [unstore_unit]
    variable=damaged_unit
    text=_"$amount_blocked blocked!"
    red,green,blue=128,128,255
  [/unstore_unit]
  {VARIABLE {DAMAGE_VAR} 0}
[/else])}
#enddef
#define mage_shield_AUXILIARY_EVENTS
{WHENEVER_DAMAGED mage_shield MAGE_SHIELD_BLOCK}
#enddef

#define fire_ball_INFO_INIT
{BASE_SPELL_STATS fire_ball   attacks/fireball.png   evocation 6   16   3}
#enddef
#define fire_ball_NAME
_"Fire Ball"#enddef
#define fire_ball_DESCRIPTION
_"Inflicts 4 to 9 fire damage plus 1.5 times your
Evocation level upon every unit in a radius-1 area
around one target within $fire_ball_base_range| hexes."#enddef
#define fire_ball_CHECK_TARGET
#enddef
#define fire_ball_AUXILIARY_EVENTS
#enddef
#define fire_ball_EFFECTS
[sound]
name=explosion.ogg
[/sound]
[store_locations]
  {IS_REASONABLE_LOCATION}
  [and]
    radius=1
    x=$x1
    y=$y1
  [/and]
  variable=victims
[/store_locations]
{FOREACH victims fire_ball_effects_i}
  {VARIABLE fbe_half_skill $evocation_skill_$side_number||}
  {VARIABLE_OP fbe_half_skill divide 2}
  {VARIABLE fbe_temp fbe_half_skill}
  {VARIABLE_OP fbe_temp multiply 2}
  {IF_VAR fbe_temp equals $evocation_skill_$side_number|| ([then]
    {RANDOM 4..9}
  [/then]
  [else]
    {RANDOM 4..10}
  [/else])}
  {VARIABLE fire_ball_damage $random}
  {VARIABLE_OP fire_ball_damage add $evocation_skill_$side_number||}
  {VARIABLE_OP fire_ball_damage add $fbe_half_skill}
  {MODIFY_DAMAGE_FOR_RESISTANCE_OF_HEX_INHABITANT_IF_ANY $victims[$fire_ball_effects_i].x $victims[$fire_ball_effects_i].y fire_ball_damage fire}
  {DAMAGE_HEX_NO_KILLING $victims[$fire_ball_effects_i].x $victims[$fire_ball_effects_i].y $fire_ball_damage}
{NEXT fire_ball_effects_i}
{KILL_IF_NEEDED ([filter_location]
  radius=1
  x=$x1
  y=$y1
[/filter_location]) $side_number}
#FOREACH victims fire_ball_effects_i}
#  #KILL_IF_NEEDED $victims[$fire_ball_effects_i].x $victims[$fire_ball_effects_i].y $side_number}
#NEXT fire_ball_effects_i}
{CLEAR_VARIABLE victims}
{CLEAR_VARIABLE fire_ball_damage}
{CLEAR_VARIABLE fbe_temp}
{CLEAR_VARIABLE fbe_half_skill}
#enddef


### NOTE TO MAINTAINER: the "dispelled and ignored" effects necessitate specific exception code in the *dispelled* effect's spell description. Dark Pact is currently an exception because its events fire after dispelling touch's events, but that's a hack and should probably be cleaned up. The merely dispelled ones only require that there be a that_enchantment_END_ENCHANTMENT macro defined, which is usually relatively simple and/or needed already, and can be given an entry here:
#define APPLY_FOR_ALL_SIMPLY_DISPELLABLE_UNIT_ENCHANTMENTS MACRO
{{MACRO} dispelling_touch}
{{MACRO} mud_touch}
{{MACRO} eohs_regeneration}
{{MACRO} reanimating_touch}
{{MACRO} dark_pact}
#enddef

#define dispelling_touch_INFO_INIT
{BASE_SPELL_STATS dispelling_touch   attacks/touch-faerie.png   evocation 5   6   0}
{IS_ENCHANTMENT dispelling_touch}
#enddef
#define dispelling_touch_NAME
_"Dispelling Touch"#enddef
############################################## warning - much of this text duplicated in the attack special description
#define dispelling_touch_DESCRIPTION
_"Places an enchantment on you that will dispel the first enemy magic
that it comes into contact with. This uses up the enchantment.
The following types of enemy magic are affected when you hit a unit in melee
(if you hit a unit with more than one of these, all are affected):
Mud Touch, Regeneration, Dispelling Touch, Reanimating Touch, Wraithform: dispelled
Mage Shield, Dark Pact: dispelled and ignored (i.e. the shield does not block anything)
Summoned creatures and undead: inflicts (skill*4) to (skill*6) damage
Also, if you end a turn on a poisoned hex, the poison is dispelled and ignored, without using up the dispelling touch."#enddef
#define dispelling_touch_CHECK_TARGET
{CANT_CAST_IF_ALREADY_ENCHANTED_WITH dispelling_touch _"You can't cast Dispelling Touch when the spell is already active."}
#enddef
#define DISPTOUCH_EFFECTS_AUX_AUX ENCHANTMENT_TYPE
{IF_VAR disptouch_victim.variables.{ENCHANTMENT_TYPE} boolean_equals true ([then]
  {VARIABLE disptouch_consumed true}
  {{ENCHANTMENT_TYPE}_END_ENCHANTMENT disptouch_victim}
[/then])}
#enddef
#define DISPTOUCH_EFFECTS_AUX XER XFILTER AFILTER YFILTER XNUM YNUM
[event]
name={XER} hits
first_time_only=no
[{XFILTER}]
  [filter_wml]
    [variables]
      dispelling_touch=true
    [/variables]
  [/filter_wml]
[/{XFILTER}]
[{AFILTER}]
  range=melee
[/{AFILTER}]
[{YFILTER}]
  [filter_location]
    {NOT_IN_ANY_CIRCLE}
  [/filter_location]
[/{YFILTER}]
  [store_unit]
    [filter]
      x=$x{XNUM}
      y=$y{XNUM}
    [/filter]
    variable=disptouch_user
  [/store_unit]
  [store_unit]
    [filter]
      x=$x{YNUM}
      y=$y{YNUM}
    [/filter]
    variable=disptouch_victim
  [/store_unit]
{IF_VAR disptouch_victim.hitpoints greater_than 0 ([then]
  {VARIABLE disptouch_consumed false}
  # wraithform is special (it has to be)
  {IF_VAR disptouch_victim.variables.wraithform boolean_equals true ([then]
    {VARIABLE disptouch_consumed true}
    {wraithform_END_ENCHANTMENT disptouch_victim}
  [/then]
  [else]
    {APPLY_FOR_ALL_SIMPLY_DISPELLABLE_UNIT_ENCHANTMENTS DISPTOUCH_EFFECTS_AUX_AUX}
    {IF_VAR disptouch_victim.variables.summoned boolean_equals true ([or]
      [variable]
        name=disptouch_victim.race
        equals=undead
      [/variable]
    [/or]
    [then]
      {VARIABLE disptouch_consumed true}
      {VARIABLE randmin $evocation_skill_$disptouch_user.side}
      {VARIABLE randmax $evocation_skill_$disptouch_user.side}
      {VARIABLE_OP randmin multiply 4}
      {VARIABLE_OP randmax multiply 6}
      {VARIABLE randstr $randmin|..$randmax}
      {RANDOM $randstr}
      {VARIABLE ehs_override_allow_damage_to_leaders true}
      {DAMAGE_HEX_NO_KILLING $disptouch_victim.x $disptouch_victim.y $random}
      {CLEAR_VARIABLE ehs_override_allow_damage_to_leaders}
    [/then])}
  [/else])}
  {IF_VAR disptouch_consumed boolean_equals true ([then]
    [sound]
      name=gunshot.wav
    [/sound]
    {dispelling_touch_END_ENCHANTMENT disptouch_user}
    {KILL_IF_NEEDED (x=$disptouch_victim.x
y=$disptouch_victim.y) $disptouch_user.side}
    #KILL_IF_NEEDED $disptouch_victim.x $disptouch_victim.y $disptouch_user.side}
  [/then])}
[/then])}
[/event]
#enddef
#define dispelling_touch_AUXILIARY_EVENTS
{DISPTOUCH_EFFECTS_AUX attacker filter        filter_attack        filter_second 1 2}
{DISPTOUCH_EFFECTS_AUX defender filter_second filter_second_attack filter        2 1}

{DUMMY_ATTACK_SPECIALS_FOR_ENCHANTMENT dispelling_touch range=melee _"dispelling touch" _"Dispelling touch:
This attack dispels the first magic it comes in contact with. This uses up the enchantment.
The following types of enemy magic are affected when you hit a unit with this attack
(if you hit a unit with more than one of these, all are affected):
Mud Touch, Regeneration, Dispelling Touch, Reanimating Touch, Wraithform: dispelled
Mage Shield, Dark Pact: dispelled and ignored (i.e. the shield does not block anything)
Summoned creatures and undead: inflicts (skill*4) to (skill*6) damage"}
#enddef
#define dispelling_touch_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.dispelling_touch false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
{UPDATE_DUMMY_ATTACK_SPECIALS ${VAR}.x ${VAR}.y}
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=halo/elven/ice-halo5.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define dispelling_touch_EFFECTS
[sound]
  name=magic-holy-2.ogg
[/sound]
{MODIFY_UNIT (x,y=$x1,$y1) variables.dispelling_touch true}
{UPDATE_DUMMY_ATTACK_SPECIALS $x1 $y1}
[unit_overlay]
  x=$x1
  y=$y1
  image=halo/elven/ice-halo5.png
[/unit_overlay]
#enddef

#define corridor_of_frost_INFO_INIT
{BASE_SPELL_STATS corridor_of_frost attacks/iceball.png   evocation 4   8   1}
{FIXED_RANGE corridor_of_frost}
#enddef
#define corridor_of_frost_NAME
_"Corridor of Frost"#enddef
#define corridor_of_frost_DESCRIPTION
_"Continues in the given direction for (your Evocation level) hexes,
slowing and inflicting 6 to 10 cold damage upon each unit in its path."#enddef
#define corridor_of_frost_CHECK_TARGET
[if]
  [not]
    [have_location]
      x=$x1
      y=$y1
      [filter_adjacent_location]
        x=$spellcasting_conduit.x
        y=$spellcasting_conduit.y
      [/filter_adjacent_location]
    [/have_location]
  [/not]
  [then]
    {CANT_CAST_WITH_MESSAGE _"To cast Corridor of Frost, you must indicate a direction by targeting a hex directly adjacent to your leader."}
  [/then]
[/if]
#enddef
#define corridor_of_frost_AUXILIARY_EVENTS
#enddef
#define COF_EFFECTS DIRECTION
[store_locations]
  x=$x1
  y=$y1
  {IS_REASONABLE_LOCATION}
  [filter_adjacent_location]
    adjacent={DIRECTION}
    x=$spellcasting_conduit.x
    y=$spellcasting_conduit.y
  [/filter_adjacent_location]
  variable=next_victim
[/store_locations]
{IF_VAR next_victim.length equals 1 ([then]
  {VARIABLE num_frost_tiles $evocation_skill_$side_number||}
  #VARIABLE_OP num_frost_tiles add -2}
  [while]
    [variable]
      name=num_frost_tiles
      greater_than=0
    [/variable]
    [do]
      {VARIABLE_OP num_frost_tiles add -1}
      {VARIABLE this_x $next_victim.x}
      {VARIABLE this_y $next_victim.y}
      {RANDOM 6..10}
      [scroll_to]
        x=$this_x
        y=$this_y
        check_fogged=true
      [/scroll_to]

      [sound]
        name=magic-faeriefire.ogg
      [/sound]

      {MODIFY_DAMAGE_FOR_RESISTANCE_OF_HEX_INHABITANT_IF_ANY $this_x $this_y random cold}
      {DAMAGE_HEX $this_x $this_y $random $side_number}
      {EHS_SHORT_DELAY}
      [store_unit]
        [filter]
	  x=$this_x
	  y=$this_y
          [filter_location]
            {NOT_IN_ANY_CIRCLE}
          [/filter_location]
	[/filter]
	variable=this_victim
      [/store_unit]
      {IF_VAR this_victim.length equals 1 ([then]
        {VARIABLE this_victim.status.slowed true}
	[unstore_unit]
	  variable=this_victim
	  text=_"slowed"
	  {COLOR_HARM}
	[/unstore_unit]
      [/then])}
      [store_locations]
        {IS_REASONABLE_LOCATION}
        [filter_adjacent_location]
          adjacent={DIRECTION}
          x=$this_x
	  y=$this_y
        [/filter_adjacent_location]
        variable=next_victim
      [/store_locations]
      {IF_VAR next_victim.length equals 0 ([then]
        {VARIABLE num_frost_tiles 0}
      [/then])}
    [/do]
  [/while]
[/then])}
{CLEAR_VARIABLE next_victim}
{CLEAR_VARIABLE this_x}
{CLEAR_VARIABLE this_y}
{CLEAR_VARIABLE this_victim}
#enddef
#define corridor_of_frost_EFFECTS
{COF_EFFECTS n}
{COF_EFFECTS ne}
{COF_EFFECTS se}
{COF_EFFECTS s}
{COF_EFFECTS sw}
{COF_EFFECTS nw}
#enddef


#define mass_teleport_INFO_INIT
{BASE_SPELL_STATS mass_teleport halo/teleport-7.png   evocation 7   22   6}
#enddef
#define mass_teleport_NAME
_"Gate"#enddef
#define mass_teleport_DESCRIPTION
_"Teleports you and all adjacent units, friendly or enemy, to a target location within $mass_teleport_base_range| hexes.
Teleported units you control can move immediately, but can't attack.
All teleported units land next to you on the same side of you as they were originally,
and in order to cast the spell at a target at all, all teleported units must land at reasonable locations.
You can't teleport any unit to the location of another unit or onto a terrain it cannot normally cross.
Gate also cannot take you to locations that are completely inaccessible by non-magical means."#enddef
#define mass_teleport_AUXILIARY_EVENTS
#enddef

#define MASS_TELEPORT_CHECK_DIRECTION_AUX_TERRAIN DIRECTION TERRAIN_MOVEMENT_NAME TERRAIN_TYPE MESSAGE
[if]
  [not]
    [variable]
      name=mttr_victim.movement_costs.{TERRAIN_MOVEMENT_NAME}
      less_than_equal_to=$mttr_victim.max_moves
    [/variable]
    [variable]
      name=mttr_victim.movement_costs.{TERRAIN_MOVEMENT_NAME}
      greater_than=0
    [/variable]
  [/not]
  [have_location]
    terrain={TERRAIN_TYPE}
    [filter_adjacent_location]
      adjacent={EHS_OPPOSITE_DIRECTION_{DIRECTION}}
      x=$x1
      y=$y1
    [/filter_adjacent_location]
  [/have_location]
  [then]
    {CANT_CAST_WITH_MESSAGE {MESSAGE}}
  [/then]
[/if]
#enddef

#define MASS_TELEPORT_CHECK_DIRECTION DIRECTION
[store_unit]
  [filter]
    [filter_adjacent]
      adjacent={EHS_OPPOSITE_DIRECTION_{DIRECTION}}
      x=$caster.x
      y=$caster.y
    [/filter_adjacent]
    [filter_location]
      {NOT_IN_ANY_CIRCLE}
    [/filter_location]
  [/filter]
  variable=mttr_victim
[/store_unit]

{IF_VAR mttr_victim.length equals 1 ([then]
  [if]
    [not]
      [have_location]
        x=1-$map_size.width
        y=1-$map_size.height
        [filter_adjacent_location]
          adjacent={EHS_OPPOSITE_DIRECTION_{DIRECTION}}
          x=$x1
          y=$y1
        [/filter_adjacent_location]
      [/have_location]
    [/not]
    [then]
      {CANT_CAST_WITH_MESSAGE _"Can't Gate: The $mttr_victim.language_name| would be teleported off the map."}
    [/then]
  [/if]
  [if]
    [have_location]
      terrain={OBSTRUCTING_TERRAINS}
      [filter_adjacent_location]
        adjacent={EHS_OPPOSITE_DIRECTION_{DIRECTION}}
        x=$x1
        y=$y1
      [/filter_adjacent_location]
    [/have_location]
    [then]
      {CANT_CAST_WITH_MESSAGE _"Can't Gate: The $mttr_victim.language_name| would be teleported into a wall."}
    [/then]
  [/if]
  {MASS_TELEPORT_CHECK_DIRECTION_AUX_TERRAIN {DIRECTION} unwalkable Ql,Qlf _"Can't Gate: The $mttr_victim.language_name| would be teleported into lava."}
  {MASS_TELEPORT_CHECK_DIRECTION_AUX_TERRAIN {DIRECTION} unwalkable Qxu _"Can't Gate: The $mttr_victim.language_name| would be teleported into a chasm."}
  {MASS_TELEPORT_CHECK_DIRECTION_AUX_TERRAIN {DIRECTION} deep_water Wo _"Can't Gate: The $mttr_victim.language_name| would be teleported into deep water."}
  {MASS_TELEPORT_CHECK_DIRECTION_AUX_TERRAIN {DIRECTION} mountains Mm,Ms,Md _"Can't Gate: The $mttr_victim.language_name| would be teleported into a mountain."}

  [if]
    [have_location]
      [filter_adjacent_location]
        adjacent={EHS_OPPOSITE_DIRECTION_{DIRECTION}}
        x=$x1
        y=$y1
      [/filter_adjacent_location]
      [and]
        # no unit on the target hex in that direction -> we're fine
        [filter]
        [/filter]
        # the target hex is one of the ones to be teleported from anyway -> we're fine
        [not]
          x=$caster.x
          y=$caster.y
          radius=1
        [/not]
      [/and]
    [/have_location]
    [then]
      {CANT_CAST_WITH_MESSAGE _"Can't Gate: The $mttr_victim.language_name| would be teleported onto another unit."}
    [/then]
  [/if]
  
#ifdef FORMULA_FILTER_ACTUALLY_WORKS
    {VARIABLE target_loc_in_formula_language "loc($mttr_target_hex_{DIRECTION}.x|,$mttr_target_hex_{DIRECTION}.y|)"}
    [store_unit]
      [filter]
        x=$mttr_victim.x
        y=$mttr_victim.y
        formula="(movement_cost(me, $target_loc_in_formula_language|) > 0) and (movement_cost($target_loc_in_formula_language|) < total_movement)"
      [/filter]
      variable=mttr_victim_actually_working
    [/store_unit]

    {IF_VAR mttr_victim_actually_working.length greater_than 0 ([then]
      # , then we're okay again:
      {CLEAR_VARIABLE mttr_extra_requirements_{DIRECTION}}
    [/then])}

    {CLEAR_VARIABLE mttr_victim_actually_working}
#endif
[/then])}

{CLEAR_VARIABLE mttr_victim}
#enddef

#define mass_teleport_CHECK_TARGET
[if]
  [have_location]
    x=$x1
    y=$y1
    # no unit on the target hex -> we're fine
    [filter]
    [/filter]
    # the target hex is one of the ones to be teleported from anyway -> we're fine
    # (but don't allow teleporting to the same location, ha ha)
    [not]
      [filter_adjacent_location]
        x=$caster.x
        y=$caster.y
      [/filter_adjacent_location]
    [/not]
  [/have_location]
  [then]
    [if]
      [have_unit]
        x=$x1
        y=$y1
        [and]
          x=$caster.x
          y=$caster.y
        [/and]
      [/have_unit]
      [then]
        {CANT_CAST_WITH_MESSAGE _"You can't teleport into the same location."}
      [/then]
      [else]
        {CANT_CAST_WITH_MESSAGE _"You can't teleport onto a unit."}
      [/else]
    [/if]
  [/then]
[/if]
{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_CHECK_DIRECTION}
#enddef


#define MASS_TELEPORT_STORE_UNIT DIRECTION
[store_unit]
  [filter]
    [filter_adjacent]
      adjacent={DIRECTION}
      x=$caster.x
      y=$caster.y
    [/filter_adjacent]
  [/filter]
  kill=yes
  variable=mte_victim_{DIRECTION}
[/store_unit]
#enddef
#define MASS_TELEPORT_MOVE_UNIT DIRECTION
{IF_VAR mte_victim_{DIRECTION}.length greater_than 0 ([then]
  [store_locations]
    [filter_adjacent_location]
      adjacent={DIRECTION}
      x=$x1
      y=$y1
    [/filter_adjacent_location]
    variable=mte_target_{DIRECTION}
  [/store_locations]
  {VARIABLE mte_victim_{DIRECTION}.x $mte_target_{DIRECTION}.x}
  {VARIABLE mte_victim_{DIRECTION}.y $mte_target_{DIRECTION}.y}
  {VARIABLE mte_victim_{DIRECTION}.attacks_left 0}
[/then])}
#enddef
#define MASS_TELEPORT_DROP_UNIT DIRECTION
{IF_VAR mte_victim_{DIRECTION}.length greater_than 0 ([then]
  [unstore_unit]
    variable=mte_victim_{DIRECTION}
    text=_"teleported"
    red,green,blue=255,255,255
  [/unstore_unit]
  [capture_village]
    x=$mte_victim_{DIRECTION}.x
    y=$mte_victim_{DIRECTION}.y
    side=$mte_victim_{DIRECTION}.side
  [/capture_village]
  [fire_event]
    name=moveto
    [primary_unit]
      x=$mte_victim_{DIRECTION}.x
      y=$mte_victim_{DIRECTION}.y
    [/primary_unit]
  [/fire_event]
[/then])}
#enddef
#define mass_teleport_EFFECTS
{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_STORE_UNIT}
{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_MOVE_UNIT}
[store_unit]
  [filter]
    x=$caster.x
    y=$caster.y
  [/filter]
  kill=yes
  variable=caster
[/store_unit]
[redraw]
  side=$side_number
[/redraw]
{VARIABLE caster.x $x1}
{VARIABLE caster.y $y1}
{VARIABLE caster.attacks_left 0}
[unstore_unit]
  variable=caster
  text=_"teleport"
  red,green,blue=255,255,255
[/unstore_unit]
[capture_village]
  x=$x1
  y=$y1
  side=$side_number
[/capture_village]
[fire_event]
  name=moveto
  [primary_unit]
    x=$x1
    y=$y1
  [/primary_unit]
[/fire_event]

{APPLY_FOR_ALL_DIRECTIONS MASS_TELEPORT_DROP_UNIT}

[sound]
  name=fanfare-short.wav
[/sound]
#enddef


#define ogrify_INFO_INIT
{BASE_SPELL_STATS ogrify units/ogres/ogre-attack3.png   evocation 8   16   1}
#enddef
#define ogrify_NAME
_"Aberrant Growth"#enddef
#define ogrify_DESCRIPTION
_"Transforms one adjacent non-leader elf, dwarf, human, goblin,
or orc into a huge Ogre. The ogre retains its experience and
will have the same fraction of its hitpoints remaining as did
the original unit, but is otherwise a completely new unit.
If a level 0 unit is hit with this spell, it will merely become
a Young Ogre.
Note that in you can replace an enemy unit with an ogre just
as well as your own units, but it will remain your enemy."#enddef
#define ogrify_CHECK_TARGET
[if]
  [have_unit]
    x=$x1
    y=$y1
  [/have_unit]
  [else] # else
    {CANT_CAST_WITH_MESSAGE _"Aberrant Growth can only be cast on a unit."}
  [/else]
[/if]  
[if]
  [have_unit]
    x=$x1
    y=$y1
    {IS_WIZARD_LEADER}
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You can't cast Aberrant Growth on wizard leaders."}
  [/then]
[/if]
[if]
  [have_unit]
    x=$x1
    y=$y1
    [not]
      race=elf
      [or]
        race=dwarf
      [/or]
      [or]
        race=human
      [/or]
      [or]
        race=goblin
      [/or]
      [or]
        race=orc
      [/or]
    [/not]
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"Aberrant Growth can only be cast on an Elf, Dwarf, Human, Goblin, or Orc."}
  [/then]
[/if]
#enddef
#define ogrify_EFFECTS
[sound]
  name=ogre-hit-1.ogg
[/sound]
[store_unit]
  [filter]
    x=$x1
    y=$y1
  [/filter]
  variable=ogrify_victim
[/store_unit]
{IF_VAR ogrify_victim.level equals 0 ([then]
  {VARIABLE ogrify_victim_type (Young Ogre)}
[/then]
[else]
  {VARIABLE ogrify_victim_type (Ogre)}
[/else])}
#ifdef DOING_IT_THE_STUPID_OLD_WAY
{EOHS_FULL_KILL mudtouch_user (x=$ogrify_victim.x
y=$ogrify_victim.y) false false}
[unit]
  to_variable=ogrify_result
  side=$ogrify_victim.side
  type=$ogrify_victim_type
  x=$ogrify_victim.x
  y=$ogrify_victim.y
  experience=$ogrify_victim.experience
  moves=0
  attacks_left=0
  upkeep=$ogrify_victim.upkeep
[/unit]
{VARIABLE_OP ogrify_result.hitpoints multiply $ogrify_victim.hitpoints}
{VARIABLE_OP ogrify_result.hitpoints divide $ogrify_victim.max_hitpoints}
[unstore_unit]
  variable=ogrify_result
  text=_"Transmogrified!"
  red,green,blue=255,208,135
[/unstore_unit]
{CHASM_FALL_IF_NEEDED $ogrify_victim.x $ogrify_victim.y $side_number}
#endif
{VARIABLE ogrify_victim.advances_to $ogrify_victim_type}
{VARIABLE ogrify_victim.experience $ogrify_victim.max_experience}
{VARIABLE ogrify_victim.variables.is_being_transmogrified_to_ogre true}
[unstore_unit]
  variable=ogrify_victim
  text=_"Transmogrified!"
  red,green,blue=255,208,135
[/unstore_unit]
#enddef
#define ogrify_AUXILIARY_EVENTS
[event]
name=post advance
first_time_only=no
[filter]
  [filter_wml]
    [variables]
      is_being_transmogrified_to_ogre=true
    [/variables]
  [/filter_wml]
[/filter]
  {VARIABLE_OP unit.hitpoints multiply $ogrify_victim.hitpoints}
  {VARIABLE_OP unit.hitpoints divide $ogrify_victim.max_hitpoints}
  {VARIABLE unit.moves $unit.max_moves}
  {VARIABLE_OP unit.moves multiply $ogrify_victim.moves}
  {VARIABLE_OP unit.moves divide $ogrify_victim.max_moves}
  {VARIABLE unit.variables.is_being_transmogrified_to_ogre true}
  [unstore_unit]
    variable=unit
  [/unstore_unit]
  {CHASM_FALL_IF_NEEDED $unit.x $unit.y $side_number}
  {CLEAR_VARIABLE ogrify_victim}
[/event]
#enddef


#define circle_of_protection_INFO_INIT
{BASE_SPELL_STATS circle_of_protection   attacks/staff-elven.png   evocation 9   18   1}
#enddef
#define circle_of_protection_NAME
_"Circle of Protection"#enddef
#define circle_of_protection_DESCRIPTION
_"Places a circle of protection at your location or at an adjacent target hex.
Units in circles of protection cannot be targetted - or affected in any way - by enemy spells,
and the circles protect against the potentially harmful affects of friendly spells as well.
If a unit is attacked while in a circle of protection, both sides will do 1/3 the normal damage.
There is no limit to how long a circle of protection lasts, but it disappears if an enemy enters it."#enddef
#define circle_of_protection_CHECK_TARGET
[if]
  [have_location]
    x=$x1
    y=$y1
    [not]
      {NOT_IN_ANY_CIRCLE}
    [/not]
  [/have_location]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You cannot create a Circle of Protection where there already is one."}
  [/then]
[/if]
#enddef
#define CLEAR_COP_LIST SIDE
{VARIABLE circles_of_protection_x_list_{SIDE} 0}
{VARIABLE circles_of_protection_y_list_{SIDE} 0}
#enddef
#define DISPEL_COP X Y SIDE
[removeitem]
  x={X}
  y={Y}
  image=scenery/circle-magic-glow.png
[/removeitem]
[removeitem]
  x={X}
  y={Y}
  image=flags/flag-icon.png~TC({SIDE},flag_green)
[/removeitem]
[store_locations]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
  [not]
    x={X}
    y={Y}
  [/not]
  variable=remaining_circles
[/store_locations]
[set_variable]
  name=circles_of_protection_x_list_{SIDE}
  [join]
    variable=remaining_circles
    key=x
    separator=,
  [/join]
[/set_variable]
[set_variable]
  name=circles_of_protection_y_list_{SIDE}
  [join]
    variable=remaining_circles
    key=y
    separator=,
  [/join]
[/set_variable]
#enddef
#define COP_STEPPING_EVENT SIDE
[event]
name=moveto
first_time_only=no
[filter]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
  # rule out as much as possible via filter, to avoid breaking undo
  [not]
    side={SIDE}
  [/not]
  [not]
    [filter_wml]
      team_name=$circle_of_protection_controller_$x1|_$y1
    [/filter_wml]
  [/not]
[/filter]
  [store_side]
    side=$side_number
    variable=stepper_side
  [/store_side]
  {IF_VAR stepper_side.team_name not_equals $circle_of_protection_controller_$x1|_$y1 ([then]
    {DISPEL_COP $x1 $y1 {SIDE}}
  [/then])}
[/event]
#enddef
#define COP_ATTACK_EVENT SIDE
[event]
name=attack
first_time_only=no
[filter_second]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
[/filter_second]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=attacker
  [/store_unit]
  {IF_VAR attacker.variables.dispelling_touch boolean_equals true ([then]
    {DISPEL_COP $x2 $y2 {SIDE}}
    [sound]
      name=gunshot.wav
    [/sound]
    {dispelling_touch_END_ENCHANTMENT attacker}
  [/then]
  [else]
    [object]
      silent=yes
      [filter]
        x=$x1
        y=$y1
      [/filter]
      [effect]
        apply_to=attack
        [set_specials]
          mode=append
          [damage]
            id=cop_damage_reduce
            multiply=0.34
            apply_to=both
          [/damage]
        [/set_specials]
      [/effect]
    [/object]
  [/else])}
[/event]
[event]
name=attack end
first_time_only=no
[filter_second]
  x=$circles_of_protection_x_list_{SIDE}
  y=$circles_of_protection_y_list_{SIDE}
[/filter_second]
  [object]
    silent=yes
    [filter]
      x=$x1
      y=$y1
    [/filter]
    [effect]
      apply_to=attack
      remove_specials=cop_damage_reduce
    [/effect]
  [/object]
[/event]
#enddef
#define circle_of_protection_AUXILIARY_EVENTS
[event]
name=prestart
  {APPLY_FOR_ALL_SIDES CLEAR_COP_LIST}
[/event]
{APPLY_FOR_ALL_SIDES COP_STEPPING_EVENT}
{APPLY_FOR_ALL_SIDES COP_ATTACK_EVENT}
#enddef
#define circle_of_protection_EFFECTS
[sound]
  name=magic-holy-miss-2.ogg
[/sound]
[store_side]
  side=$side_number
  variable=caster_side
[/store_side]
{VARIABLE circle_of_protection_controller_$x1|_$y1 $current_side_info.team_name}
{VARIABLE circles_of_protection_x_list_$side_number $circles_of_protection_x_list_$side_number||,$x1}
{VARIABLE circles_of_protection_y_list_$side_number $circles_of_protection_y_list_$side_number||,$y1}
[item]
  x=$x1
  y=$y1
  halo=scenery/circle-magic-glow.png
[/item]
[item]
  x=$x1
  y=$y1
  image=flags/flag-icon.png~TC($side_number|,flag_green)
[/item]
#enddef



#define meteor_storm_INFO_INIT
{BASE_SPELL_STATS meteor_storm   attacks/curse.png   evocation 13   150   12}
#enddef
#define meteor_storm_NAME
_"Meteor Storm"#enddef
#define meteor_storm_DESCRIPTION
_"Drops 10 to 13 flaming boulders near one target within $meteor_storm_base_range| hexes.
Units and terrain in the area will be severly damaged, including destruction of villages and keeps."#enddef
#define meteor_storm_CHECK_TARGET
#enddef
#define meteor_storm_AUXILIARY_EVENTS
#enddef
#define METEOR_TERRAIN_MOD DAMAGE_COST SRC_TYPES DST_TYPE LAYER EXTRA_STUFF
{IF_VAR meteor_damage greater_than_equal_to {DAMAGE_COST} ([and]
  [have_location]
    x=$x
    y=$y
    terrain={SRC_TYPES}
  [/have_location]
[/and]
[then]
  [terrain]
    x=$x
    y=$y
    layer={LAYER}
    terrain={DST_TYPE}
  [/terrain]
  {VARIABLE_OP meteor_damage add -{DAMAGE_COST}}
  {EXTRA_STUFF}
[/then])}
#enddef
#define meteor_storm_EFFECTS
{RANDOM 10..13}
{VARIABLE boulders_left $random}
[store_locations]
  {IS_REASONABLE_LOCATION}
  [and]
    x=$x1
    y=$y1
    radius=6
    [filter_radius]
      {IS_REASONABLE_LOCATION}
    [/filter_radius]
  [/and]
  variable=possible_targets
[/store_locations]
[store_locations]
  {IS_REASONABLE_LOCATION}
  [and]
    x=$x1
    y=$y1
    radius=4
    [filter_radius]
      {IS_REASONABLE_LOCATION}
    [/filter_radius]
  [/and]
  variable=preferred_targets
[/store_locations]

[while]
  [variable]
    name=boulders_left
    greater_than=0
  [/variable]
  [do]
    {RANDOM 1..3}
    {IF_VAR random equals 1 ([then]
      {RANDOM 1..$possible_targets.length}
      {VARIABLE center_x $possible_targets[$random].x}
      {VARIABLE center_y $possible_targets[$random].y}
    [/then]
    [else]
      {RANDOM 1..$preferred_targets.length}
      {VARIABLE center_x $preferred_targets[$random].x}
      {VARIABLE center_y $preferred_targets[$random].y}
    [/else])}
    {RANDOM explosion.ogg,dragonstick.ogg}
    [sound]
      name=$random
    [/sound]
    {DO_TO_EXPANDING_SERIES_OF_HEXES $center_x $center_y 2 (
      {RANDOM 14..36}
      {VARIABLE meteor_damage $random}
      {VARIABLE_OP meteor_damage add $evocation_skill_$side_number||}
      {VARIABLE_OP meteor_damage add $evocation_skill_$side_number||}
      {VARIABLE_OP distance add 1}
      {VARIABLE_OP meteor_damage divide $distance}
      {DAMAGE_HEX_NO_KILLING $x $y $meteor_damage}

      [if]
      [have_location]
        x=$x
        y=$y
        {NOT_IN_ANY_CIRCLE}
      [/have_location]
      [then]

      {METEOR_TERRAIN_MOD -2 *^Gvs Gg overlay ()}
      {METEOR_TERRAIN_MOD 5 "*^Bw/,*^Bw\,*^Bw|" Ww overlay ([sound]
  name=cave-in.ogg
[/sound])}

      {METEOR_TERRAIN_MOD 10 Ai^*  Ww  base ()}
      {METEOR_TERRAIN_MOD 15 Aa^*  Gg  base ()}

      {METEOR_TERRAIN_MOD 25 Ce^*  Re  base ()}
      {METEOR_TERRAIN_MOD 30 Ke^*  Re  base ()}
      {METEOR_TERRAIN_MOD 20 Ch^*  Chr base ()}
      {METEOR_TERRAIN_MOD 25 Kh^*  Khr base ()}
      {METEOR_TERRAIN_MOD 25 Cv^*  Chr base ()}
      {METEOR_TERRAIN_MOD 30 Kv^*  Khr base ()}
      {METEOR_TERRAIN_MOD 30 Cud^* Chr base ()}
      {METEOR_TERRAIN_MOD 35 Kud^* Khr base ()}

      {METEOR_TERRAIN_MOD 20 "Chr^*,Chw^*,Chs^*" Dd^Dr both ()}
      {METEOR_TERRAIN_MOD 25 "Khr^*,Khw^*,Khs^*" Dd^Dr both ()}

      {METEOR_TERRAIN_MOD 15 Ww^V^* Ww both ()}
      {METEOR_TERRAIN_MOD 20 "*^V*,*^F*,Gg^Wm" "^Dr" (overlay) ([sound]
  name=ambient/campfire.ogg
[/sound])}
      {METEOR_TERRAIN_MOD 10 "*^Uf,*^Ufi" "^Dr" (overlay) ()}
      {METEOR_TERRAIN_MOD 10 "*^Ufi" "^Ii" (overlay) ()}

      {METEOR_TERRAIN_MOD 15 "*^Do" Ds overlay ()}
      {METEOR_TERRAIN_MOD 5 Dd^* Ds base ()}
      {METEOR_TERRAIN_MOD 10 "Re^*,Rd^*,Rr^*,Rp^*,Ur^*" Ds base ()}
      {METEOR_TERRAIN_MOD 18 "Gg^*,Ggf^*,Gs^*" Ds base ()}
      {METEOR_TERRAIN_MOD 15 Wwr^* Ww base ()}
      {METEOR_TERRAIN_MOD 20 Wwf^* Ww base ()}
      {METEOR_TERRAIN_MOD 20 Ss^* Ds base ()}
      {METEOR_TERRAIN_MOD 12 Ha^* Hh base ()}
      {METEOR_TERRAIN_MOD 12 Hh^* Hd base ()}
      {METEOR_TERRAIN_MOD 12 Ms^* Mm base ()}
      {METEOR_TERRAIN_MOD 35 Mm^* Md base ()}
      {METEOR_TERRAIN_MOD 46 Md^* Hd base ()}
      {METEOR_TERRAIN_MOD 25 Hd^* Dd^Dr both ()}

      {METEOR_TERRAIN_MOD 0 Ds^Dr Dd^Dr both ()}

      {METEOR_TERRAIN_MOD 30 Ww^* Wo base ()}

      {METEOR_TERRAIN_MOD 40 Ds Dd^Dc both ()}
      {METEOR_TERRAIN_MOD 45 Dd^Dr Dd^Dc both ()}
      {RANDOM 1..3}
      {IF_VAR random equals 1 ([then]
        {METEOR_TERRAIN_MOD 50 Qlf^* Ql base ()}
        {METEOR_TERRAIN_MOD 55 Dd^Dc,Uu^*,Uh^*,Wo^* Qxu both ()}
        {CHASM_FALL_IF_NEEDED $x $y $side_number}
      [/then])}

      [/then]
      [/if]
    )}
    {RANDOM 1..3}
    {IF_VAR random equals 1 ([then]
      {EHS_SHORT_DELAY}
      {EHS_SHORT_DELAY}
      {EHS_SHORT_DELAY}
    [/then])}
    [redraw]
    [/redraw]
    {KILL_IF_NEEDED ([filter_location]
  x=$x1
  y=$y1
  radius=2
  [filter_radius]
    {IS_REASONABLE_LOCATION}
  [/filter_radius]
[/filter_location]) $side_number}
    {VARIABLE_OP boulders_left add -1}
  [/do]
[/while]
# HACK - kill any dead units; TODO - fix the bug that makes this necessary
{KILL_IF_NEEDED () $side_number}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{RANDOM 1..3}
[sound]
  name=ambient/birds$random|.ogg
[/sound]
{EHS_SHORT_DELAY}
{EHS_SHORT_DELAY}
{RANDOM 1..3}
[sound]
  name=ambient/birds$random|.ogg
[/sound]
#enddef


