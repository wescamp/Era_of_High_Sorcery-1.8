#textdomain wesnoth-Era_of_High_Sorcery

#define mud_touch_INFO_INIT
{BASE_SPELL_STATS mud_touch attacks/mud-glob.png   nature_magic 2   6   0}
{IS_ENCHANTMENT mud_touch}
#enddef
#define mud_touch_NAME
_"Mud Touch"#enddef
#define mud_touch_DESCRIPTION
_"Enchants you so that the next time you hit a living or undead unit in melee, that unit
is immediately turned into a ghastly mudcrawler, ending the fight immediately.
The mudcrawler retains the hitpoints, max hitpoints, and experience of the
original unit, but otherwise is a completely new unit. Level 0 units are changed
into level 0 Mudcrawlers; everything else becomes a level 1 Giant Mudcrawler.
(Has no effect on enemy leaders or units that are already mudcrawlers.)"#enddef
#define mud_touch_CHECK_TARGET
{CANT_CAST_IF_ALREADY_ENCHANTED_WITH mud_touch _"You can't cast Mud Touch when the spell is already active."}
#enddef
#define mud_touch_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.mud_touch false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
{UPDATE_DUMMY_ATTACK_SPECIALS ${VAR}.x ${VAR}.y}
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=projectiles/mud-glob.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define mud_touch_EFFECTS
[sound]
  name=squishy-hit.wav
[/sound]
{MODIFY_UNIT (x,y=$x1,$y1) variables.mud_touch true}
{UPDATE_DUMMY_ATTACK_SPECIALS $x1 $y1}
[unit_overlay]
  x=$x1
  y=$y1
  image=projectiles/mud-glob.png
[/unit_overlay]
#enddef
#define MUDTOUCH_EFFECTS_AUX XER YER XFILTER AFILTER YFILTER XNUM YNUM
[event]
name={XER} hits
first_time_only=no
[{XFILTER}]
  [filter_wml]
    [variables]
      mud_touch=true
    [/variables]
  [/filter_wml]
[/{XFILTER}]
[{AFILTER}]
  range=melee
[/{AFILTER}]
[{YFILTER}]
  [not]
    {IS_WIZARD_LEADER}
  [/not]
  [filter_location]
    {NOT_IN_ANY_CIRCLE}
  [/filter_location]
  [not]
    type=Mudcrawler,Giant Mudcrawler
  [/not]
  [not]
    [filter_wml]
      [status]
        not_living="yes"
      [/status]
    [/filter_wml]
    [not]
      race=undead
    [/not]
  [/not]
[/{YFILTER}]
  [sound]
    name=squishy-hit.wav
  [/sound]

  [store_unit]
    [filter]
      x=$x{XNUM}
      y=$y{XNUM}
    [/filter]
    variable=mudtouch_user
  [/store_unit]

  [store_unit]
    [filter]
      x=$x{YNUM}
      y=$y{YNUM}
    [/filter]
    variable=mudtouch_victim
  [/store_unit]
{IF_VAR mudtouch_victim.hitpoints greater_than 0 ([then]
  {mud_touch_END_ENCHANTMENT mudtouch_user}

  {IF_VAR mudtouch_victim.level equals 0 ([then]
    {VARIABLE mudtouch_victim_type (Mudcrawler)}
    {VARIABLE xp_wasted_by_mudtouch 0}
  [/then]
  [else]
    {VARIABLE mudtouch_victim_type (Giant Mudcrawler)}
    {VARIABLE xp_wasted_by_mudtouch $mudtouch_victim.level}
    {VARIABLE_OP xp_wasted_by_mudtouch add -1}
    # only multiply by 7, since kills are typically worth 7 XP when you factor in the fight XP
    {VARIABLE_OP xp_wasted_by_mudtouch multiply 7}
  [/else])}
  {EOHS_FULL_KILL mudtouch_user (x=$mudtouch_victim.x
y=$mudtouch_victim.y) false false}
  [unit]
    to_variable=mudtouch_result
    side=$mudtouch_victim.side
    type=$mudtouch_victim_type
    x=$mudtouch_victim.x
    y=$mudtouch_victim.y
    experience=$mudtouch_victim.experience
    hitpoints=$mudtouch_victim.hitpoints
    max_hitpoints=$mudtouch_victim.max_hitpoints
    moves=0
    attacks_left=0
    upkeep=0
  [/unit]
  [unstore_unit]
    variable=mudtouch_result
    text=_"Transmogrified!"
    red,green,blue=128,80,40
  [/unstore_unit]
  {CHASM_FALL_IF_NEEDED $mudtouch_victim.x $mudtouch_victim.y $mudtouch_user.side}
  # gain the wasted XP back, along with the fight experience
  {VARIABLE_OP mudtouch_user.experience add $xp_wasted_by_mudtouch}
  [unstore_unit]
    variable=mudtouch_user
  [/unstore_unit]
[/then])}
[/event]
#enddef
#define mud_touch_AUXILIARY_EVENTS
{MUDTOUCH_EFFECTS_AUX attacker defender filter        filter_attack        filter_second 1 2}
{MUDTOUCH_EFFECTS_AUX defender attacker filter_second filter_second_attack filter        2 1}

{DUMMY_ATTACK_SPECIALS_FOR_ENCHANTMENT mud_touch range=melee _"mud touch" _"Mud touch:
When a unit is hit with this attack, that unit is turned into a mudcrawler, which ends the fight immediately. This doesn't work on wizard leaders or mechanical units. The Mud Touch enchantment also ends when a unit is so transformed."}
#enddef

#define grow_trees_INFO_INIT
{BASE_SPELL_STATS grow_trees attacks/entangle.png   nature_magic 3   11   6}
#enddef
#define grow_trees_NAME
_"Grow Trees"#enddef
#define grow_trees_DESCRIPTION
_"Grows trees on all hexes within a (your Nature Magic skill / 4)-radius area of
any target within $grow_trees_base_range| hexes. Some terrains are unaffected.
The radius isn't rounded down - rather, hexes on the edge of the radius have a
random chance of being affected."#enddef
#define grow_trees_CHECK_TARGET
#enddef
#define grow_trees_AUXILIARY_EVENTS
#enddef
#define GROWTREES_RULE TERR
[rule]
  old={TERR}
  new=Gs
  terrain={TERR}^Fp
[/rule]
[rule]
  old={TERR}^Gvs
  new=Gs
  terrain={TERR}^Fp
[/rule]
#enddef
#define grow_trees_EFFECTS
[sound]
name=entangle.wav
[/sound]
[sound]
name=entangle.wav
[/sound]
[sound]
name=entangle.wav
[/sound]
{VARIABLE max_tree_rad $nature_magic_skill_$side_number}
{VARIABLE_OP max_tree_rad add 3}
{VARIABLE_OP max_tree_rad divide 4}
{VARIABLE edge_skill $max_tree_rad}
{VARIABLE_OP edge_skill multiply -4}
{VARIABLE_OP edge_skill add $nature_magic_skill_$side_number}
{VARIABLE_OP edge_skill add 3}
{VARIABLE radius_iterator 0}
{VARIABLE radius_iterator_old -1}
[while]
  [variable]
    name=radius_iterator
    less_than_equal_to=$max_tree_rad
  [/variable]
  [do]
    {IF_VAR radius_iterator_old less_than 0 ([then]
      [store_locations]
        x=0
        y=0
        variable=tree_location_pile
      [/store_locations]
    [/then]
    [else]
      [store_locations]
        x=$x1
        y=$y1
        radius=$radius_iterator_old
	[filter_radius]
          [not]
            terrain={OBSTRUCTING_TERRAINS}
          [/not]
        [/filter_radius]
        variable=tree_location_pile
      [/store_locations]
    [/else])}
    [store_locations]
      [not]
        find_in=tree_location_pile
      [/not]
      [and]
        x=$x1
        y=$y1
        radius=$radius_iterator
	[filter_radius]
          [not]
            terrain={OBSTRUCTING_TERRAINS}
          [/not]
        [/filter_radius]
      [/and]
      variable=tree_location_pile
    [/store_locations]

    {FOREACH tree_location_pile gte_i}
      {RANDOM 0..3}
      {IF_VAR radius_iterator less_than $max_tree_rad ([or]
        [variable]
	  name=edge_skill
	  greater_than_equal_to=$random
	[/variable]
      [/or]
      [then]
{VARIABLE mask_x $tree_location_pile[$gte_i].x}
{VARIABLE mask_y $tree_location_pile[$gte_i].y}

      [if]
      [have_location]
        x=$mask_x
        y=$mask_y
        {NOT_IN_ANY_CIRCLE}
      [/have_location]
      [then]

 [terrain_mask]
x=$mask_x
y=$mask_y
mask="usage=mask
border_size=0

Gs
"
{GROWTREES_RULE Gg}
{GROWTREES_RULE Ggf}
{GROWTREES_RULE Gs}
{GROWTREES_RULE Rd}
{GROWTREES_RULE Re}
{GROWTREES_RULE Rr}
{GROWTREES_RULE Rp}
{GROWTREES_RULE Hh}
{GROWTREES_RULE Ha}
{GROWTREES_RULE Ds}
{GROWTREES_RULE Dd}
{GROWTREES_RULE Ss}
#GROWTREES_RULE Wwf}
[rule]
  old=Uu
  new=Gs
  terrain=Uu^Uf
[/rule]
[rule]
  old=Aa
  new=Gs
  terrain=Aa^Fpa
[/rule]
[rule]
  use_old=yes
[/rule]
[/terrain_mask]
      [/then]
      [/if]
      [/then])}
    {NEXT gte_i}
    {VARIABLE_OP radius_iterator add 1}
    {VARIABLE_OP radius_iterator_old add 1}
  [/do]
[/while]
[redraw]
[/redraw]
#enddef

#define regeneration_INFO_INIT
{BASE_SPELL_STATS regeneration attacks/fangs-spider.png   nature_magic 5   10   1}
{IS_ENCHANTMENT regeneration}
#enddef
#define regeneration_NAME
_"Regeneration"#enddef
#define regeneration_DESCRIPTION
_"Immediately heals an adjacent unit for 2 to 4 hitpoints plus your
Nature Magic skill, and grants it the ability to regenerate by
(Nature Magic skill * 2) hitpoints per turn for six turns."#enddef
#define regeneration_CHECK_TARGET
#enddef
#define regeneration_AUXILIARY_EVENTS
[event]
name=turn refresh
first_time_only=no
  [store_unit]
    [filter]
      side=$side_number
      [filter_wml]
        [variables]
          eohs_regeneration=true
          #loses_eohs_regen_on=$turn_number
	[/variables]
      [/filter_wml]
    [/filter]
    variable=regen_losers
  [/store_unit]
  {FOREACH regen_losers wsae_i}
    {IF_VAR regen_losers[$wsae_i].variables.loses_eohs_regen_on less_than_equal_to $turn_number ([then]
      {eohs_regeneration_END_ENCHANTMENT regen_losers[$wsae_i]}
    [/then])}
  {NEXT wsae_i}
[/event]
#enddef
#define eohs_regeneration_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.eohs_regeneration false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
[object]
  silent=yes
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  [effect]
    apply_to=remove_ability
    [abilities]
      [regenerate]
        id=nature_magic_regenerates
      [/regenerate]
    [/abilities]
  [/effect]
[/object]
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=halo/elven/nature-halo6.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define regeneration_EFFECTS
{RANDOM 2..4}
{VARIABLE regeneration_healing $random}
{VARIABLE_OP regeneration_healing add $nature_magic_skill_$side_number||}
[store_unit]
  [filter]
    x=$x1
    y=$y1
  [/filter]
  variable=regeneratee
[/store_unit]
{VARIABLE new_hitpoints $regeneratee.hitpoints}
{VARIABLE_OP new_hitpoints add $regeneration_healing}
{IF_VAR new_hitpoints greater_than $regeneratee.max_hitpoints ([then]
  {VARIABLE new_hitpoints $regeneratee.max_hitpoints}
  {VARIABLE regeneration_healing $new_hitpoints}
  {VARIABLE_OP regeneration_healing add -$regeneratee.hitpoints}
[/then])}
{IF_VAR regeneration_healing greater_than 0 ([then]
  [sound]
    name=heal.wav
  [/sound]
  {VARIABLE regeneratee.hitpoints $new_hitpoints}
  [unstore_unit]
    variable=regeneratee
    text=$regeneration_healing
    {COLOR_HEAL}
  [/unstore_unit]
  #EHS_SHORT_DELAY}
[/then])}

{VARIABLE regeneration_amount $nature_magic_skill_$side_number}
{VARIABLE_OP regeneration_amount multiply 2}

{IF_VAR regeneratee.variables.eohs_regeneration boolean_equals true ([then]
  {VARIABLE need_to_add_halo false}
[/then]
[else]
  {VARIABLE need_to_add_halo true}
[/else])}

  [sound]
    name=heal.wav
  [/sound]
  {VARIABLE regeneratee.variables.eohs_regeneration true}
  {VARIABLE regeneratee.variables.loses_eohs_regen_on $turn_number}
  {VARIABLE_OP regeneratee.variables.loses_eohs_regen_on add 6}
  [unstore_unit]
    variable=regeneratee
    text=_"regenerates +$regeneration_amount"
    {COLOR_HEAL}
  [/unstore_unit]

  {IF_VAR need_to_add_halo boolean_equals true ([then]
    [unit_overlay]
      x=$x1
      y=$y1
      image=halo/elven/nature-halo6.png
    [/unit_overlay]
  [/then])}

  [object]
    silent=yes
    [filter]
      x=$x1
      y=$y1
    [/filter]
    [effect]
      apply_to=remove_ability
      [abilities]
        [regenerate]
          id=nature_magic_regenerates ####### NOTE - this means a weaker nature mage can reduce the regeneration given by a stronger nature mage. TODO: fix this?
        [/regenerate]
      [/abilities]
    [/effect]
    [effect]
      apply_to=new_ability
      [abilities]
        [regenerate]
          value=$regeneration_amount
          id=nature_magic_regenerates
          name= _ "regenerates +$regeneration_amount"
          female_name= _ "female^regenerates +$regeneration_amount"
          description= _ "Regenerates +$regeneration_amount:

The unit will heal itself $regeneration_amount HP per turn. If it is poisoned, it will remove the poison instead of healing.

This ability was granted by a spell, and is temporary. It will disappear on turn $regeneratee.variables.loses_eohs_regen_on|."
          affect_self=yes
          poison=cured
        [/regenerate]
      [/abilities]
    [/effect]
  [/object]
{CLEAR_VARIABLE regeneratee}
{CLEAR_VARIABLE regeneration_healing}
{CLEAR_VARIABLE regeneration_amount}
{CLEAR_VARIABLE new_hitpoints}
#enddef


#define tailwind_INFO_INIT
{BASE_SPELL_STATS tailwind icons/circlet_winged.png   nature_magic 6   3   1}
{IS_ENCHANTMENT tailwind}
#enddef
#define tailwind_NAME
_"Tailwind"#enddef
#define tailwind_DESCRIPTION
_"Enchants you or an adjacent unit, increasing their moves by two for
both the current turn and the following turn. This effect is cumulative.
Units that have already used all their moves for the turn don't get
extra moves on the same turn, but still do on the following turn."#enddef
#define tailwind_CHECK_TARGET
#enddef
#define tailwind_EFFECTS
[sound]
  name=magic-missile-3-miss.ogg
[/sound]
[store_unit]
  [filter]
    x=$x1
    y=$y1
  [/filter]
  variable=speedy
[/store_unit]
{IF_VAR speedy.moves greater_than 0 ([then]
  {VARIABLE_OP speedy.moves add 2}
[/then])}
{VARIABLE speedy.variables.tailwind true}
{VARIABLE_OP speedy.variables.tailwind_bonus add 2}
[unstore_unit]
  variable=speedy
[/unstore_unit]
#enddef
#define tailwind_AUXILIARY_EVENTS
[event]
name=turn refresh
first_time_only=no
  [store_unit]
    [filter]
      side=$side_number
      [filter_wml]
        [variables]
          tailwind=true
        [/variables]
      [/filter_wml]
    [/filter]
    variable=speedy
  [/store_unit]
  {FOREACH speedy tae_i}
    {IF_VAR speedy[$tae_i].moves greater_than 0 ([then] # 0 moves at turn start is normally impossible, but this handles lightning and otherwise deliberately immobile units.
      {VARIABLE_OP speedy[$tae_i].moves add $speedy[$tae_i].variables.tailwind_bonus}
    [/then])}
    {VARIABLE speedy[$tae_i].variables.tailwind false}
    {VARIABLE speedy[$tae_i].variables.tailwind_bonus 0}
    [unstore_unit]
      variable=speedy[$tae_i]
    [/unstore_unit]
  {NEXT tae_i}
[/event]
#enddef

#define lightning_bolt_INFO_INIT
{BASE_SPELL_STATS lightning_bolt attacks/lightning.png   nature_magic 7   14   8}
#enddef
#define lightning_bolt_NAME
_"Lightning Bolt"#enddef
#define lightning_bolt_DESCRIPTION
_"Inflicts 12 to 18 damage plus your Nature Magic level upon one target within $lightning_bolt_base_range| hexes,
and, if it's still alive, paralyzes it so that it can't move on its next turn.
Paralyzed units normally cannot attack either, but paralyzed leaders can.
Undead can be paralyzed, but mechanical units cannot."#enddef
#define lightning_bolt_CHECK_TARGET
#enddef
#define LIGHTNING_PARALYSIS_EFFECT VAR
    {VARIABLE {VAR}.moves 0}
    {VARIABLE {VAR}.variables.lightning_paralysis overlay_retaining}
    [if]
      [have_unit]
        x=${VAR}.x
        y=${VAR}.y
        {IS_WIZARD_LEADER}
      [/have_unit]
      [else] # else
        {VARIABLE {VAR}.attacks_left 0}
      [/else]
    [/if]
    {VARIABLE {VAR}.resting false}
    [unstore_unit]
      variable={VAR}
    [/unstore_unit]
#enddef
#define lightning_bolt_AUXILIARY_EVENTS
[event]
  name=turn refresh
  first_time_only=no
  [store_unit]
    [filter]
      [filter_wml]
        [variables]
	  lightning_paralysis=overlay_retaining
	[/variables]
      [/filter_wml]
    [/filter]
    variable=lparalyzed
  [/store_unit]
  {FOREACH lparalyzed lbae_i}
    {VARIABLE lparalyzed[$lbae_i].variables.lightning_paralysis false}
    [remove_unit_overlay]
      x=$lparalyzed[$lbae_i].x
      y=$lparalyzed[$lbae_i].y
      image=projectiles/gaze.png
    [/remove_unit_overlay]
  {NEXT lbae_i}

  [store_unit]
    [filter]
      side=$side_number
      [filter_wml]
        [variables]
	  lightning_paralysis=active
	[/variables]
      [/filter_wml]
    [/filter]
    variable=lparalyzed
  [/store_unit]
  {FOREACH lparalyzed lbae_i}
    {LIGHTNING_PARALYSIS_EFFECT lparalyzed[$lbae_i]}
  {NEXT lbae_i}
[/event]
#enddef
#define lightning_bolt_EFFECTS
[sound]
name=lightning.ogg
[/sound]
{RANDOM 12..18}
{VARIABLE lightning_bolt_damage $random}
{VARIABLE_OP lightning_bolt_damage add $nature_magic_skill_$side_number||}
{DAMAGE_HEX $x1 $y1 $lightning_bolt_damage $side_number}
{CLEAR_VARIABLE lightning_bolt_damage}
[store_unit]
  [filter]
    x=$x1
    y=$y1
    [and]
      [not]
        [filter_wml]
          [status]
            not_living=yes
          [/status]
        [/filter_wml]
      [/not]
      [or]
        race=undead
      [/or]
    [/and]
  [/filter]
  variable=lightning_victim
[/store_unit]
{IF_VAR lightning_victim.length equals 1 ([then]
  {EHS_SHORT_DELAY}
  {VARIABLE lightning_victim.variables.lightning_paralysis active}
  {VARIABLE lightning_victim.status.slowed true}
  [unstore_unit]
    variable=lightning_victim
    text=_ "paralyzed"
    {COLOR_HARM}
  [/unstore_unit]
  {IF_VAR lightning_victim.side equals $side_number ([then] # special exception to make sure lightning works properly when you, for some reason, strike one of your own units
    {LIGHTNING_PARALYSIS_EFFECT lightning_victim}
  [/then])}
  [unit_overlay]
    x=$x1
    y=$y1
    image=projectiles/gaze.png
  [/unit_overlay]
[/then])}
#enddef

#define fissure_INFO_INIT
{BASE_SPELL_STATS fissure attacks/fangs.png   nature_magic 8   21   2}
#enddef
#define fissure_NAME
_"Fissure"#enddef
#define fissure_DESCRIPTION
_"Irrevocably opens up a chasm hex up to $fissure_base_range| hexes away.
Any unit in the hex that is unable to fly will be instantly killed.
Unlike other spells, you do not gain experience for a unit killed this way."#enddef
#define fissure_CHECK_TARGET
#enddef
#define fissure_AUXILIARY_EVENTS
#enddef
#define fissure_EFFECTS
[sound]
name=cave-in.ogg
[/sound]
[sound]
name=rumble.ogg
[/sound]
[terrain]
  x=$x1
  y=$y1
  terrain=Qxu
[/terrain]
{CHASM_FALL_IF_NEEDED $x1 $y1 $side_number}
#enddef

#define rampage_INFO_INIT
{BASE_SPELL_STATS rampage attacks/frenzy.png   nature_magic 9   28   0}
#enddef
#define rampage_NAME
_"Rampage"#enddef
#define rampage_DESCRIPTION
_"Until the end of your turn, empowers you and all adjacent units on your team
with primal energy, granting +3 damage and +1 swings on on their melee attacks
and making them take 50% less damage in combat. You can personally attack after
casting this spell, but you cannot cast additional spells."#enddef
#define rampage_CHECK_TARGET
#enddef
#define rampage_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.rampage false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=misc/new-battle.png
[/remove_unit_overlay]
[object]
  silent=yes
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  [effect]
    apply_to=attack
    range=melee
    increase_damage=-3
    increase_attacks=-1
  [/effect]
  [effect]
    apply_to=attack
    remove_specials=rampage_damage_reduce
  [/effect]
[/object]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define rampage_AUXILIARY_EVENTS
[event]
name=side turn
first_time_only=no
  [store_unit]
    [filter]
      [filter_wml]
        [variables]
	  rampage=true
	[/variables]
      [/filter_wml]
    [/filter]
    variable=rampage_losers
  [/store_unit]
  {FOREACH rampage_losers rae_i}
    {rampage_END_ENCHANTMENT rampage_losers[$rae_i]}
  {NEXT rae_i}
[/event]
#enddef
#define rampage_EFFECTS
[sound]
name=drake-hit-2.ogg
[/sound]
[store_unit]
  [filter]
    side=$side_number
    [filter_location]
      radius=1
      x=$caster.x
      y=$caster.y
    [/filter_location]
  [/filter]
  variable=rampagers
[/store_unit]
{FOREACH rampagers reff_i}
  {VARIABLE rampagers[$reff_i].variables.rampage true}
  [if]
    [have_unit]
      x=$rampagers[$reff_i].x
      y=$rampagers[$reff_i].y
      {IS_WIZARD_LEADER}
    [/have_unit]
    [then]
      {VARIABLE_OP rampagers[$reff_i].attacks_left add 1}
    [/then]
  [/if]
  [unstore_unit]
    variable=rampagers[$reff_i]
    text=_"rampage!"
    red,green,blue=255,128,0
  [/unstore_unit]
  [unit_overlay]
    x=$rampagers[$reff_i].x
    y=$rampagers[$reff_i].y
    image=misc/new-battle.png
  [/unit_overlay]
  [object]
    silent=yes
    [filter]
      x=$rampagers[$reff_i].x
      y=$rampagers[$reff_i].y
    [/filter]
    [effect]
      apply_to=attack
      range=melee
      increase_damage=3
      increase_attacks=1
    [/effect]
    [effect]
      apply_to=attack
      [set_specials]
        mode=append
	[damage]
	  name=_"rampage"
	  id=rampage_damage_reduce
	  apply_to=opponent
	  multiply=0.5
	  cumulative=yes
	[/damage]
      [/set_specials]
    [/effect]
  [/object]
{NEXT reff_i}
#enddef

#define blizzard_INFO_INIT
{BASE_SPELL_STATS blizzard attacks/faerie-fire.png   nature_magic 10   19   12}
#enddef
#define blizzard_NAME
_"Blizzard"#enddef
#define blizzard_DESCRIPTION
_"Snows on a large area, centered up to $blizzard_base_range| hexes away.
Snow created this way melts after 4 to 8 turns; ice melts after 1 to 3 turns."#enddef
#define blizzard_CHECK_TARGET
#enddef
#define BAE_SET_TERRAIN LAYER
{IF_VAR blizzarded_hexes[$bae_i].terrain not_equals Qxu ([then] # Hack - don't reverse chasming
          [terrain]
	    x=$bae_x
	    y=$bae_y
	    terrain=$blizzarded_hexes_$bae_x|_$bae_y|_old_terrain
	    layer={LAYER}
	  [/terrain]
[/then])}
#enddef
#define blizzard_AUXILIARY_EVENTS
[event]
  name=prestart
  {VARIABLE blizzarded_hexes_x_list 0}
  {VARIABLE blizzarded_hexes_y_list 0}
[/event]
[event]
name=side turn
  first_time_only=no
  [store_locations]
    x=$blizzarded_hexes_x_list
    y=$blizzarded_hexes_y_list
    variable=blizzarded_hexes
  [/store_locations]

  {VARIABLE no_longer_blizzarded_hexes_x_list 0}
  {VARIABLE no_longer_blizzarded_hexes_y_list 0}

  {FOREACH blizzarded_hexes bae_i}
    {VARIABLE bae_x $blizzarded_hexes[$bae_i].x}
    {VARIABLE bae_y $blizzarded_hexes[$bae_i].y}
    # Don't just revert the blizzarding on the exact turn it should be; revert it on any turn then or after (to make sure none of the hexes falls through and remains snowy forever - e.g. if a turn is skipped somehow, which can happen various ways)
    [if]
      [variable]
        name=turn_number
        greater_than=$blizzarded_hexes_$bae_x|_$bae_y|_timeout_turn
      [/variable]
      [or]
        [variable]
          name=turn_number
          greater_than_equal_to=$blizzarded_hexes_$bae_x|_$bae_y|_timeout_turn
        [/variable]
        [variable]
          name=side_number
          greater_than_equal_to=$blizzarded_hexes_$bae_x|_$bae_y|_timeout_side
        [/variable]
      [/or]
      [then]
        {IF_VAR blizzarded_hexes_$bae_x|_$bae_y|_both_blizzarded boolean_equals true ([then]
	  {BAE_SET_TERRAIN both}
	[/then]
	[else]
          {IF_VAR blizzarded_hexes_$bae_x|_$bae_y|_base_blizzarded boolean_equals true ([then]
	    {IF_VAR blizzarded_hexes_$bae_x|_$bae_y|_overlay_blizzarded boolean_equals true ([then]
	      {BAE_SET_TERRAIN both}
	    [/then]
            [else]
	      {BAE_SET_TERRAIN base}
	    [/else])}
	  [/then]
	  [else]
            {IF_VAR blizzarded_hexes_$bae_x|_$bae_y|_overlay_blizzarded boolean_equals true ([then]
	      {BAE_SET_TERRAIN overlay}
	    [/then])}
	  [/else])}
	[/else])}
	{VARIABLE no_longer_blizzarded_hexes_x_list $no_longer_blizzarded_hexes_x_list|,$bae_x}
	{VARIABLE no_longer_blizzarded_hexes_y_list $no_longer_blizzarded_hexes_y_list|,$bae_y}
	{VARIABLE blizzarded_hexes_$bae_x|_$bae_y|_is_blizzarded false}
 
        {DROWN_IF_NEEDED $bae_x $bae_y 0} # "0" means nobody gets credit for the kill. Really, it's not in any way the blizzard-caster's responsibility that someone walked over deep water.

	{CLEAR_VARIABLE blizzarded_hexes_$bae_x|_$bae_y|_base_blizzarded}
	{CLEAR_VARIABLE blizzarded_hexes_$bae_x|_$bae_y|_overlay_blizzarded}
	{CLEAR_VARIABLE blizzarded_hexes_$bae_x|_$bae_y|_both_blizzarded}
	{CLEAR_VARIABLE blizzarded_hexes_$bae_x|_$bae_y|_old_terrain}
      [/then]
    [/if]

    {CLEAR_VARIABLE bae_x}
    {CLEAR_VARIABLE bae_y}
  {NEXT bae_i}

  [store_locations]
    x=$blizzarded_hexes_x_list
    y=$blizzarded_hexes_y_list
    [not]
      x=$no_longer_blizzarded_hexes_x_list
      y=$no_longer_blizzarded_hexes_y_list
    [/not]
    variable=blizzarded_hexes
  [/store_locations]
  [set_variable]
    name=blizzarded_hexes_x_list
    [join]
      variable=blizzarded_hexes
      key=x
      separator=,
    [/join]
  [/set_variable]
  {VARIABLE blizzarded_hexes_x_list $blizzarded_hexes_x_list|,0}
  [set_variable]
    name=blizzarded_hexes_y_list
    [join]
      variable=blizzarded_hexes
      key=y
      separator=,
    [/join]
  [/set_variable]
  {VARIABLE blizzarded_hexes_y_list $blizzarded_hexes_y_list|,0}

  {CLEAR_VARIABLE blizzarded_hexes}
  {CLEAR_VARIABLE no_longer_blizzarded_hexes_x_list}
  {CLEAR_VARIABLE no_longer_blizzarded_hexes_y_list}
[/event]
#enddef
#define BLIZZARD_RULE A B LAYER
[if]
  [have_location]
    x=$x
    y=$y
    terrain={A}
  [/have_location]
  [then]
    [terrain]
      x=$x
      y=$y
      layer={LAYER}
      terrain={B}
    [/terrain]
    {VARIABLE blizzarded_hexes_$x|_$y|_{LAYER}_blizzarded true}
  [/then]
[/if]
#enddef
#define blizzard_EFFECTS
[sound]
name=magic-faeriefire-miss.ogg
[/sound]
{DO_TO_EXPANDING_SERIES_OF_HEXES $x1 $y1 7 (
    {VARIABLE radsq $distance}
    {VARIABLE_OP radsq multiply $radsq}
    {RANDOM 0..64}
    {IF_VAR radsq less_than $random ([then]

      [if]
      [have_location]
        x=$x
        y=$y
        {NOT_IN_ANY_CIRCLE}
      [/have_location]
      [then]

	{VARIABLE blizzarded_hexes_$x|_$y|_timeout_turn $turn_number}
	{VARIABLE blizzarded_hexes_$x|_$y|_timeout_side $side_number}
	[if]
	  [have_location]
	    x=$x
	    y=$y
	    terrain=Ww^*,Wo^*,Ss^*,Wwf^*,Wwr^*
	  [/have_location]
	  [then]
	    {RANDOM 1..3}
	  [/then]
	  [else]
	    {RANDOM 4..8}
	  [/else]
	[/if]
	{VARIABLE_OP blizzarded_hexes_$x|_$y|_timeout_turn add $random}

        {IF_VAR blizzarded_hexes_$x|_$y|_is_blizzarded boolean_equals true ([then]
	  # nothing to do but update the timeout time
	[/then]
	[else]
	  {VARIABLE blizzarded_hexes_$x|_$y|_is_blizzarded true}
	  {VARIABLE blizzarded_hexes_$x|_$y|_old_terrain $terrain}
	  {VARIABLE blizzarded_hexes_x_list $blizzarded_hexes_x_list|,$x}
	  {VARIABLE blizzarded_hexes_y_list $blizzarded_hexes_y_list|,$y}

          {BLIZZARD_RULE Gg^Ve Aa^Vea both}
          {BLIZZARD_RULE Gg^Vh Aa^Vha both}
          {BLIZZARD_RULE Hh^Vhh Ha^Vhha both}
          {BLIZZARD_RULE Mm^Vhm Ms^Vhha both}
          {BLIZZARD_RULE Gg^Vc Aa^Vca both}
          {BLIZZARD_RULE Hh^Vc Ha^Vcha both}

          {BLIZZARD_RULE Gg^*,Ggf^*,Gs^*,Rd^*,Re^*,Rr^*,Rp^*,Dd^*,Ds^* Aa base}
          {BLIZZARD_RULE Hh^*,Hd^* Ha base}
          {BLIZZARD_RULE Mm^*,Md^* Ms base}
          {BLIZZARD_RULE Ww^*,Wo^*,Ss^*,Wwf^*,Wwr^* Ai base}

          {BLIZZARD_RULE *^Fp ^Fpa overlay}
          {BLIZZARD_RULE *^Fd* ^Fda overlay}
          {BLIZZARD_RULE *^Fm* ^Fma overlay}
	[/else])}
      [/then]
      [/if]
    [/then])}
)}
[redraw]
[/redraw]

#enddef


#define vines_spell_INFO_INIT
{BASE_SPELL_STATS vines_spell attacks/druidstaff.png   nature_magic 10   29   5}
#enddef
#define vines_spell_NAME
_"Vines"#enddef
#define vines_spell_DESCRIPTION
_"Immediately fills all empty hexes within a radius-3 area, up to $vines_spell_range| hexes away,
with obstructing vines. The vines are units on your team that cannot move.
The vines have no attacks, but they have 15 HP, they exert Zone of Control,
and they give a 50% attack damage penalty to all adjacent units.
They have the same defenses and resistances as a Wose."#enddef
#define vines_spell_CHECK_TARGET
#enddef
#define vines_spell_AUXILIARY_EVENTS
#enddef
#define vines_spell_EFFECTS
[store_locations]
  [not]
    [filter]
    [/filter]
  [/not]
  [and]
    x=$x1
    y=$y1
    radius=3
    [filter_radius]
      [not]
        terrain={OBSTRUCTING_TERRAINS}
      [/not]
    [/filter_radius]
  [/and]
  variable=vined_hexes
[/store_locations]

{FOREACH vined_hexes vse_i}
  [unit]
    to_variable=new_vine
    type=Galleon
    side=$side_number
    x=$vined_hexes[$vse_i].x
    y=$vined_hexes[$vse_i].y

[modifications]
[object]
[effect]
apply_to=new_animation
    [standing_anim]
      start_time=0
      [frame]
        duration=2000
        image="projectiles/entangle.png"
      [/frame]
    [/standing_anim]
    [defend]
      start_time=0
      [frame]
        duration=0
	image="projectiles/entangle.png"
      [/frame]
    [/defend]
    [/effect]
    [/object]
    [/modifications]
    languagename=_"Vines"

    [variables]
      summoned=true
    [/variables]

    alignment=neutral
    race=wose
    description=_"Vines have no attacks, but are useful for obstructing the enemy's progress."

    hitpoints=15
    max_hitpoints=15
    zoc=on
    level=0
    [abilities]
      [leadership]
        id=vines_attack_penalty
        value=-50
        cumulative=no
        affect_allies=yes
	affect_enemies=yes
	name= _ "slows adjacent"
        description= _ "Slows adjacent:
This unit gives all adjacent units, friendly or enemy, a non-cumulative 50% attack penalty in combat."
        [affect_adjacent]
          adjacent=n,ne,se,s,sw,nw
        [/affect_adjacent]
      [/leadership]
    [/abilities]

    moves=1
    max_moves=1
    [movement_costs]
      castle="100"
      cave="100"
      deep_water="100"
      flat="100"
      forest="100"
      frozen="100"
      fungus="100"
      hills="100"
      impassable="100"
      mountains="100"
      reef="100"
      sand="100"
      shallow_water="100"
      swamp_water="100"
      unwalkable="100"
      village="100"
    [/movement_costs]
    [defense]
      deep_water=90
      shallow_water=80
      reef=80
      swamp_water=70
      flat=80
      sand=80
      forest=60
      hills=70
      mountains=70
      village=80
      castle=80
      cave=80
      frozen=80
      unwalkable=80
      impassable=80
      fungus=70
    [/defense]
    [resistance]
      blade=100
      pierce=40
      impact=60
      fire=150
      cold=90
      arcane=130
    [/resistance]
  [/unit]

  #{CLEAR_VARIABLE new_vine.modifications}

  [unstore_unit]
    variable=new_vine
  [/unstore_unit]
  {CLEAR_VARIABLE new_vine}
{NEXT vse_i}
#enddef

