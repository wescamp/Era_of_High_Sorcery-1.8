#textdomain wesnoth-Era_of_High_Sorcery


#define reanimating_touch_INFO_INIT
{BASE_SPELL_STATS reanimating_touch attacks/touch-zombie.png   necromancy 3   4   0}
{IS_ENCHANTMENT reanimating_touch}
#enddef
#define reanimating_touch_NAME
_"Reanimating Touch"#enddef
#define reanimating_touch_DESCRIPTION
_"Enchants you so that the next time you kill a living unit with your melee attack,
that unit is reanimated into an undead version with full hitpoints on your side.
The unit becomes non-living, chaotic, and loyal, has altered resistances,
gains Submerge, can move in deep water, and counts as a summoned unit."#enddef
#define reanimating_touch_CHECK_TARGET
{CANT_CAST_IF_ALREADY_ENCHANTED_WITH reanimating_touch _"You can't cast Reanimating Touch when the spell is already active."}
#enddef
#define reanimating_touch_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.reanimating_touch false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
{UPDATE_DUMMY_ATTACK_SPECIALS ${VAR}.x ${VAR}.y}
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=projectiles/darkmissile-ne.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define reanimating_touch_EFFECTS
[sound]
  name=zombie-attack.wav
[/sound]
{MODIFY_UNIT (x,y=$x1,$y1) variables.reanimating_touch true}
{UPDATE_DUMMY_ATTACK_SPECIALS $x1 $y1}
[unit_overlay]
  x=$x1
  y=$y1
  image=projectiles/darkmissile-ne.png
[/unit_overlay]
#enddef
#define REANTOUCH_ADVANCEMENT_REPEATED_EFFECTS
  {VARIABLE reantouch_victim.race undead}
  {VARIABLE reantouch_victim.language_name _"Reanimated "+$reantouch_victim.language_name}
  {VARIABLE reantouch_victim.alignment chaotic}
  {IF_VAR reantouch_victim.movement_costs.deep_water greater_than 0 ([else] # else
    {IF_VAR reantouch_victim.movement_costs.shallow_water greater_than 0 ([then] # then
      {VARIABLE reantouch_victim.movement_costs.deep_water $reantouch_victim.movement_costs.shallow_water}
      {VARIABLE_OP reantouch_victim.movement_costs.deep_water add 1}
      {VARIABLE reantouch_victim.defense.deep_water $reantouch_victim.defense.shallow_water}
      {VARIABLE_OP reantouch_victim.defense.deep_water add 10}
    [/then])}
  [/else])}
#enddef
#define REANTOUCH_EFFECTS_AUX XER YER XFILTER AFILTER YFILTER XNUM YNUM
[event]
name={XER} hits
first_time_only=no
[{XFILTER}]
  [filter_wml]
    [variables]
      reanimating_touch=true
    [/variables]
  [/filter_wml]
[/{XFILTER}]
[{AFILTER}]
  range=melee
[/{AFILTER}]
[{YFILTER}]
  [filter_location]
    {NOT_IN_ANY_CIRCLE}
  [/filter_location]
  [not]
    [filter_wml]
      [status]
        not_living="yes"
      [/status]
    [/filter_wml]
  [/not]
[/{YFILTER}]

  [store_unit]
    [filter]
      x=$x{YNUM}
      y=$y{YNUM}
    [/filter]
    variable=reantouch_victim
  [/store_unit]

{IF_VAR reantouch_victim.hitpoints less_than_equal_to 0 ([then]
  [store_unit]
    [filter]
      x=$x{XNUM}
      y=$y{XNUM}
    [/filter]
    variable=reantouch_user
  [/store_unit]
  {reanimating_touch_END_ENCHANTMENT reantouch_user}

  [sound]
    name=lich-hit-1.ogg
  [/sound]

  [object]
    [filter]
      x=$x{YNUM}
      y=$y{YNUM}
    [/filter]
    silent=yes
    [effect]
      apply_to=hitpoints
      heal_full=yes
    [/effect]
    [effect]
      apply_to=loyal
      heal_full=yes
    [/effect]
    [effect]
      apply_to=resistance
      replace=false
      [resistance]
        arcane=50
        fire=10
        blade=-10
        pierce=-30
        cold=-40
      [/resistance]
    [/effect]
    [effect]
      apply_to=new_ability
      [abilities]
        {ABILITY_SUBMERGE}
      [/abilities]
    [/effect]
  [/object]
  # take into account the presence of the object
  [store_unit]
    [filter]
      x=$x{YNUM}
      y=$y{YNUM}
    [/filter]
    variable=reantouch_victim
  [/store_unit]

  {VARIABLE reantouch_victim.variables.is_reanimated_undead true}
  {VARIABLE reantouch_victim.variables.summoned true}
  {VARIABLE reantouch_victim.side $reantouch_user.side}
  {VARIABLE reantouch_victim.attacks_left 0}
  {VARIABLE reantouch_victim.moves 0}
  {VARIABLE reantouch_victim.name _"Undead "+$reantouch_victim.name}
  {VARIABLE reantouch_victim.overlays $reantouch_victim.overlays|,misc/loyal-icon.png,projectiles/darkmissile-n.png}
  #VARIABLE reantouch_victim.overlays "$reantouch_victim.overlays|,misc/loyal-icon.png,$reantouch_victim.image|~GS()"}
  {VARIABLE reantouch_victim.status.not_living yes}
  {VARIABLE reantouch_victim.status.poisoned no}
  {VARIABLE reantouch_victim.status.canrecruit no}
  {VARIABLE reantouch_victim.variables.EoHS_special_is_wizard_leader false}
  {IF_VAR reantouch_victim.variables.EoHS_special_can_cast_spells boolean_equals true ([then]
    {VARIABLE reantouch_victim.variables.EoHS_special_can_cast_spells false}
    {VARIABLE reantouch_victim.variables.EoHS_special_is_spellcasting_proxy true}
    # No EoHS_special_spellcasting_proxy_caster_filter - this can cast for you from anywhere.
  [/then])}

  {REANTOUCH_ADVANCEMENT_REPEATED_EFFECTS}

  [set_variables]
    name=reantouch_victim.modifications.trait
    mode=append
    [value]
     # the contents of the TRAIT_UNDEAD macro. Don't know how to add this without copying them (so that I can omit the [trait] tag...)
        id=undead
        availability="musthave"
        male_name= _ "undead"
        female_name= _ "female^undead"
        description= _ "Immune to drain, poison and plague"
        [effect]
            apply_to=status
            add=not_living
        [/effect]
    [/value]
  [/set_variables]

  {EOHS_FULL_KILL reantouch_user (x=$reantouch_victim.x
y=$reantouch_victim.y) true false}

  [unstore_unit]
    variable=reantouch_victim
    text=_"Reanimated!"
    red,green,blue=0,0,0
  [/unstore_unit]
  [capture_village]
    x=$reantouch_victim.x
    y=$reantouch_victim.y
    side=$reantouch_victim.side
  [/capture_village]
  [redraw]
    side=$reantouch_victim.side
  [/redraw]
[/then])}
[/event]
#enddef
#define reanimating_touch_AUXILIARY_EVENTS
{REANTOUCH_EFFECTS_AUX attacker defender filter filter_attack filter_second 1 2}
{REANTOUCH_EFFECTS_AUX defender attacker filter_second filter_second_attack filter 2 1}

{DUMMY_ATTACK_SPECIALS_FOR_ENCHANTMENT reanimating_touch range=melee _"reanimating touch" _"Reanimating touch:
When a unit is killed by this attack, that unit is reanimated into an undead version with full hitpoints on your own side. This doesn't work on non-living units. The Reanimating Touch enchantment also ends when it is used on a unit."}

[event]
name=post_advance
first_time_only=no
[filter]
  [filter_wml]
    [variables]
      is_reanimated_undead=true
    [/variables]
  [/filter_wml]
[/filter]
  
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=reantouch_victim
  [/store_unit]
  {REANTOUCH_ADVANCEMENT_REPEATED_EFFECTS}
  [unstore_unit]
    variable=reantouch_victim
  [/unstore_unit]
[/event]
#enddef

#define absorb_vampire_bat_INFO_INIT
{BASE_SPELL_STATS absorb_vampire_bat units/undead/zombie-bat-die-3.png   necromancy 5   0   1}
{FREELY_CASTABLE absorb_vampire_bat}
{FIXED_PRICE absorb_vampire_bat}
#enddef
#define absorb_vampire_bat_NAME
_"Absorb bat"#enddef
#define absorb_vampire_bat_DESCRIPTION
_"Absorbs one of your bats that is adjacent to you. You regain the gold you spent to create it.
You may not absorb a bat that was just summoned, or one that has already attacked this turn.
This does not use up your spell or attack for the turn."#enddef
#define absorb_vampire_bat_AUXILIARY_EVENTS
#enddef
#define absorb_vampire_bat_CHECK_TARGET
[if]
  [not]
    [have_unit]
      x=$x1
      y=$y1
    [/have_unit]
  [/not]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You can't absorb a bat where there is no unit."}
  [/then]
[/if]
[if]
  [have_unit]
    x=$x1
    y=$y1
    [not]
      type=Vampire Bat,Blood Bat,Dread Bat
    [/not]
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You can only absorb Vampire Bats, Blood Bats, and Dread Bats."}
  [/then]
[/if]
[if]
  [have_unit]
    x=$x1
    y=$y1
    type=Vampire Bat,Blood Bat,Dread Bat
    [not]
      side=$side_number
    [/not]
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You can only absorb your own bats."}
  [/then]
[/if]
[if]
  [have_unit]
    x=$x1
    y=$y1
    type=Vampire Bat,Blood Bat,Dread Bat
    [filter_wml]
      attacks_left=0
    [/filter_wml]
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You can't absorb bats with no attacks left."}
  [/then]
[/if]
#enddef
#define absorb_vampire_bat_EFFECTS
[sound]
  name=magic-dark-big-miss.ogg
[/sound]
[store_unit]
  [filter]
    x=$x1
    y=$y1
  [/filter]
  variable=dying_bat
[/store_unit]
{VARIABLE force_gold_regain false}
{VARIABLE gold_regained 0}
{VARIABLE gold_regained $dying_bat.variables.price_originally_summoned_for}
{IF_VAR gold_regained greater_than 0 ([else] # else
  # hack - must have been recruited
  {VARIABLE force_gold_regain true}
  {VARIABLE gold_regained 13}
[/else])}

{IF_VAR EoHS_uses_mana_instead_of_gold boolean_equals false ([or]
  [variable]
    name=force_gold_regain
    equals=true
  [/variable]
[/or]
[then]
  [gold]
    side=$side_number
    amount=$gold_regained
  [/gold]
  [unstore_unit]
    variable=caster
    text=_"+$gold_regained gold"
    red,green,blue=255,226,0
  [/unstore_unit]
[/then]
[else]
  {VARIABLE_OP eohs_mana_$side_number add $gold_regained}
  [unstore_unit]
    variable=caster
    text=_"+$gold_regained mana"
    red,green,blue=255,255,255
  [/unstore_unit]
[/else])}

[kill]
  x=$x1
  y=$y1
  animate=yes
  fire_event=yes
[/kill]
{CLEAR_VARIABLE dying_bat}
#enddef

#define poison_ground_INFO_INIT
{BASE_SPELL_STATS poison_ground attacks/touch-undead.png   necromancy 5   15   3}
#enddef
#define poison_ground_NAME
_"Poison Ground"#enddef
#define poison_ground_DESCRIPTION
_"Permanently corrupts most of a radius-2 area around
one target up to $poison_ground_base_range| hexes away.
Any living unit on the corrupted area when the spell is cast is poisoned.
Any living unit standing on the corrupted area and the end of a turn is poisoned.
Greater necromancy skill increases the likelihood of poisoning each hex."#enddef
#define poison_ground_CHECK_TARGET
#enddef
#define POISON_GROUND_TERRAIN_ALTERATION SOURCE_TERRAINS DEST_TERRAIN DEST_LAYER
[store_locations]
  x=$poisoned_hexes_x_list
  y=$poisoned_hexes_y_list
  terrain={SOURCE_TERRAINS}
  variable=poison_victims
[/store_locations]
{FOREACH poison_victims pgta_i}
  [terrain]
    x=$poison_victims[$pgta_i].x
    y=$poison_victims[$pgta_i].y
    terrain={DEST_TERRAIN}
    layer={DEST_LAYER}
  [/terrain]
{NEXT pgta_i}
#enddef
#define poison_ground_AUXILIARY_EVENTS
[event]
name=prestart
  {VARIABLE poisoned_hexes_x_list 0}
  {VARIABLE poisoned_hexes_y_list 0}
[/event]
[event]
name=side turn
first_time_only=no
  [store_unit]
    [filter]
      x=$poisoned_hexes_x_list
      y=$poisoned_hexes_y_list
      [not]
        [filter_wml]
          [status]
            not_living=yes
          [/status]
        [/filter_wml]
      [/not]
      [not]
        [filter_wml]
          [status]
            petrified=true
          [/status]
        [/filter_wml]
      [/not]
    [/filter]
    variable=poison_victims
  [/store_unit]
  {FOREACH poison_victims pgae_i}
    {IF_VAR poison_victims[$pgae_i].variables.dispelling_touch boolean_equals true ([then]
      {VARIABLE this_hex_x $poison_victims[$pgae_i].x}
      {VARIABLE this_hex_y $poison_victims[$pgae_i].y}
      [removeitem]
        x=$this_hex_x
        y=$this_hex_y
        image=items/potion-poison.png
      [/removeitem]
      [store_locations]
        x=$poisoned_hexes_x_list
        y=$poisoned_hexes_y_list
	[not]
	  x=$this_hex_x
	  y=$this_hex_y
	[/not]
	variable=poisoned_hexes_array
      [/store_locations]
      [set_variable]
        name=poisoned_hexes_x_list
	[join]
	  variable=poisoned_hexes_array
	  key=x
	  separator=,
	[/join]
      [/set_variable]
      [set_variable]
        name=poisoned_hexes_y_list
	[join]
	  variable=poisoned_hexes_array
	  key=y
	  separator=,
	[/join]
      [/set_variable]
    [/then]
    [else]
      {VARIABLE poison_victims[$pgae_i].status.poisoned on}
      [unstore_unit]
        variable=poison_victims[$pgae_i]
      [/unstore_unit]
    [/else])}
  {NEXT pgae_i}

  # Cosmetic terrain effects of poisoned ground
  {POISON_GROUND_TERRAIN_ALTERATION *^Fma,*^Fpa Aa^Fda overlay}
  {POISON_GROUND_TERRAIN_ALTERATION *^Fp,*^Ft,*^Fds,*^Fdf,*^Fms,*^Fmf,*^Fmw Re^Fdw overlay}
  #{POISON_GROUND_TERRAIN_ALTERATION Gs^F* Re^Fdw both}
  #{POISON_GROUND_TERRAIN_ALTERATION Gg^*,Ggf^*,Gs^* Re base}
  #{POISON_GROUND_TERRAIN_ALTERATION Re^Gvs Re both}
[/event]
#enddef
#define poison_ground_EFFECTS
{VARIABLE pge_randstring $necromancy_skill_$side_number||}
{VARIABLE_OP pge_randstring add 3}
{VARIABLE pge_randstring 1..$pge_randstring}
[sound]
name=poison.ogg
[/sound]
[store_locations]
  x=$x1
  y=$y1
  radius=2
  [filter_radius]
    [not]
      terrain={OBSTRUCTING_TERRAINS}
    [/not]
  [/filter_radius]
  variable=maybe_poisoned
[/store_locations]
{FOREACH maybe_poisoned pge_i}
  {RANDOM $pge_randstring}
  {IF_VAR random greater_than 3 ([then]

    {VARIABLE this_hex_x $maybe_poisoned[$pge_i].x}
    {VARIABLE this_hex_y $maybe_poisoned[$pge_i].y}
      [if]
      [have_location]
        x=$this_hex_x
        y=$this_hex_y
        {NOT_IN_ANY_CIRCLE}
      [/have_location]
      [then]

    {VARIABLE this_hex_poisoned_varname ground_is_poisoned_$this_hex_x|_$this_hex_y|}
      {IF_VAR $this_hex_poisoned_varname boolean_equals true ([else] # else
        {VARIABLE $this_hex_poisoned_varname true}
        {VARIABLE poisoned_hexes_x_list $this_hex_x|,$poisoned_hexes_x_list}
        {VARIABLE poisoned_hexes_y_list $this_hex_y|,$poisoned_hexes_y_list}
        [item]
          x=$this_hex_x
          y=$this_hex_y
	  image=items/potion-poison.png
        [/item]
        {MODIFY_UNIT (
x=$this_hex_x
y=$this_hex_y
[not]
  race=undead
[/not]
[not]
  [filter_wml]
    [status]
      petrified=true
    [/status]
  [/filter_wml]
[/not]
        ) status.poisoned true}
    [/else])}
    [/then]
    [/if]
  [/then])}
{NEXT pge_i}
#enddef

#define dark_pact_INFO_INIT
{BASE_SPELL_STATS dark_pact items/altar-evil.png   necromancy 6   12   1}
{IS_ENCHANTMENT dark_pact}
#enddef
#define dark_pact_NAME
_"Dark Pact"#enddef
################################################### warning - this description is partially duplicated below in the dummy ability description
#define dark_pact_DESCRIPTION
_"You or an adjacent target unit on your side forms a permanent dark pact.
Whenever that unit is damaged, half the damage will be restored at the expense
of leeching an equal number of hitpoints from any other units on your side
that are within 5 hexes. If there are no such units, the protection is void.
Additional Necromancy skill improves the amount of damage deflected."#enddef
#define dark_pact_CHECK_TARGET
{CANT_CAST_IF_ALREADY_ENCHANTED_WITH dark_pact _"You can't cast a Dark Pact on a unit that already has one."}
[if]
  [have_unit]
    x=$x1
    y=$y1
    [not]
      side=$side_number
    [/not]
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"Dark Pact can only be cast on your own units."}
  [/then]
[/if]
#enddef
#define dark_pact_END_ENCHANTMENT VAR
{VARIABLE {VAR}.variables.dark_pact false}
[unstore_unit]
  variable={VAR}
[/unstore_unit]
{REMOVE_DUMMY_ABILITY_FOR_ENCHANTMENT (x,y=${VAR}.x|,${VAR}.y|) dark_pact}
[remove_unit_overlay]
  x=${VAR}.x
  y=${VAR}.y
  image=halo/undead/dark-magic-5.png
[/remove_unit_overlay]
[store_unit]
  [filter]
    x=${VAR}.x
    y=${VAR}.y
  [/filter]
  variable={VAR}
[/store_unit]
#enddef
#define dark_pact_EFFECTS
[sound]
  name=magic-holy-4.ogg
[/sound]
{MODIFY_UNIT (x,y=$x1,$y1) variables.dark_pact true}
{MODIFY_UNIT (x,y=$x1,$y1) variables.dark_pact_caster_side $side_number|}
{GIVE_DUMMY_ABILITY_FOR_ENCHANTMENT (x,y=$x1,$y1) dark_pact _"male^dark pact" _"female^dark pact" _"Dark Pact:

Whenever this unit is damaged, half the damage will be restored at the expense
of leeching an equal number of hitpoints from any other units on its side
that are within 5 hexes. If there are no such units, the protection is void."}
[unit_overlay]
  x=$x1
  y=$y1
  image=halo/undead/dark-magic-5.png
[/unit_overlay]
#enddef
#define DARKPACT_SPREAD_DAMAGE DAMAGE_VAR
{IF_VAR damaged_unit.variables.mage_shield boolean_not_equals true ([and]
  [variable]
    name={DAMAGE_VAR}
    greater_than=0
  [/variable]
[/and]
[and]
  [variable]
    name=damaged_unit.hitpoints
    greater_than=0
  [/variable]
[/and]
[then]
{VARIABLE damage_restored ${DAMAGE_VAR}}
{VARIABLE damage_restoration_dividend $necromancy_skill_$damaged_unit.variables.dark_pact_caster_side}
{VARIABLE_OP damage_restoration_dividend add -2}
{VARIABLE damage_restoration_divisor $necromancy_skill_$damaged_unit.variables.dark_pact_caster_side}
{VARIABLE_OP damage_restoration_divisor add 2}
{VARIABLE_OP damage_restored multiply $damage_restoration_dividend}
{VARIABLE_OP damage_restored divide $damage_restoration_divisor}

{VARIABLE dkpt_dam_range 5}

    [store_unit]
      [filter]
        side=$damaged_unit.side
        [not]
	  x=$damaged_unit.x
	  y=$damaged_unit.y
	[/not]
	[not]
	  {IS_WIZARD_LEADER}
	[/not]
	[not]
	  [filter_wml]
	    [variables]
	      dark_pact=true
	    [/variables]
	  [/filter_wml]
	[/not]
        [filter_location]
	  x=$damaged_unit.x
	  y=$damaged_unit.y
	  radius=$dkpt_dam_range
	[/filter_location]
	[filter_location]
	  x=$damaged_unit.x
	  y=$damaged_unit.y
	  radius=100
	  [filter_radius]
	    [not]
	      terrain={OBSTRUCTING_TERRAINS}
	    [/not]
	  [/filter_radius]
	[/filter_location]
      [/filter]
      variable=possible_hit_takers
    [/store_unit]
    {IF_VAR possible_hit_takers.length greater_than 0 ([then]
      {VARIABLE damage_left_to_distribute $damage_restored}
      {VARIABLE base_damage_to_each $damage_left_to_distribute}
      {VARIABLE_OP base_damage_to_each divide $possible_hit_takers.length}
      {VARIABLE base_damage_total $base_damage_to_each}
      {VARIABLE_OP base_damage_total multiply $possible_hit_takers.length}
      {VARIABLE_OP damage_left_to_distribute add -$base_damage_total}
      {VARIABLE number_to_distribute_over $possible_hit_takers.length}
      {FOREACH possible_hit_takers dpsd_i}
        {RANDOM 1..$number_to_distribute_over}
	{VARIABLE damage_to_this $base_damage_to_each}
	{IF_VAR random less_than_equal_to $damage_left_to_distribute ([then]
          {VARIABLE_OP damage_to_this add 1}
	  {VARIABLE_OP damage_left_to_distribute add -1}
	[/then])}
	{DAMAGE_HEX_NO_KILLING $possible_hit_takers[$dpsd_i].x $possible_hit_takers[$dpsd_i].y $damage_to_this}
	{VARIABLE_OP number_to_distribute_over add -1}
      {NEXT dpsd_i}
      {VARIABLE_OP damaged_unit.hitpoints add $damage_restored}
      {VARIABLE_OP damage_inflicted add -$damage_restored}
      [unstore_unit]
        variable=damaged_unit
	text=$damage_restored
	{COLOR_HEAL}
      [/unstore_unit]
      {KILL_IF_NEEDED (find_in=possible_hit_takers) 0}
      #FOREACH possible_hit_takers dpsd_i}
        #KILL_IF_NEEDED $possible_hit_takers[$dpsd_i].x $possible_hit_takers[$dpsd_i].y 0}
      #NEXT dpsd_i}
    [/then])}
[/then])}
#enddef
#define dark_pact_AUXILIARY_EVENTS
{WHENEVER_DAMAGED dark_pact DARKPACT_SPREAD_DAMAGE}
#enddef

#define wraithform_INFO_INIT
{BASE_SPELL_STATS wraithform attacks/wail.png   necromancy 8   9   0}
#enddef
#define wraithform_NAME
_"Wraithform"#enddef
#define wraithform_DESCRIPTION
_"You transform into a Wraith, or Spectre, depending on your level.
The effect lasts as long as you wish, and you can end it at any time
via a drop-down menu option. However, you can't cast spells or train
in magic when you are a Wraith, and if you die as a Wraith, you're dead.
Transforming - in either direction - preserves your current hitpoints
and approximately preserves the fraction of your moves that you have left.
You can immediately attack after becoming a Wraith, but you can't
attack or cast spells on the turn you return to wizard form.
The Wraith cannot level up, but you keep all experience it gains."#enddef
#define wraithform_CHECK_TARGET
#enddef
#define wraithform_END_ENCHANTMENT VAR
      {VARIABLE wraith_side ${VAR}.side}
      {VARIABLE stored_non_wraith_form_${VAR}.side|.x ${VAR}.x}
      {VARIABLE stored_non_wraith_form_${VAR}.side|.y ${VAR}.y}
      {VARIABLE stored_non_wraith_form_${VAR}.side|.hitpoints ${VAR}.hitpoints}
      {VARIABLE stored_non_wraith_form_${VAR}.side|.experience ${VAR}.experience}
      {VARIABLE stored_non_wraith_form_${VAR}.side|.attacks_left 0}
      {VARIABLE stored_non_wraith_form_${VAR}.side|.moves $stored_non_wraith_form_${VAR}.side|.max_moves}
      {VARIABLE_OP stored_non_wraith_form_${VAR}.side|.moves multiply ${VAR}.moves}
      {VARIABLE_OP stored_non_wraith_form_${VAR}.side|.moves divide ${VAR}.max_moves}
      [unstore_unit]
        variable=stored_non_wraith_form_${VAR}.side
      [/unstore_unit]
      {VARIABLE wraithform_${VAR}.side false}
#enddef
#define wraithform_AUXILIARY_EVENTS
{EOHS_MENU_ITEM eohs_end_wraithform "attacks/fist-human.png" _"End Wraithform" (
      [variable]
        name=wraithform_$side_number
        boolean_equals=true
      [/variable]
)
()
(
      [scroll_to_unit]
        side=$side_number
	{IS_WIZARD_LEADER}
	check_fogged=true
      [/scroll_to_unit]
      [sound]
        name=magic-dark-miss.ogg
      [/sound]
      [store_unit]
        [filter]
          side=$side_number
	  {IS_WIZARD_LEADER}
	[/filter]
	kill=yes
	variable=old_wraith_form
      [/store_unit]
      {wraithform_END_ENCHANTMENT old_wraith_form}
)}
#enddef
#define wraithform_EFFECTS
[sound]
  name=magic-holy-miss-1.ogg
[/sound]
{VARIABLE wraithform_$side_number true}
[store_unit]
  [filter]
    x=$caster.x
    y=$caster.y
  [/filter]
  kill=yes
  variable=stored_non_wraith_form_$side_number
[/store_unit]
{IF_VAR stored_non_wraith_form_$side_number|.level greater_than_equal_to 3 ([then]
  {VARIABLE wraithform_type Spectre}
[/then]
[else]
  {VARIABLE wraithform_type Wraith}
[/else])}
[unit]
  to_variable=new_wraithform
  x=$stored_non_wraith_form_$side_number|.x
  y=$stored_non_wraith_form_$side_number|.y
  side=$stored_non_wraith_form_$side_number|.side
  hitpoints=$stored_non_wraith_form_$side_number|.hitpoints
  max_hitpoints=$stored_non_wraith_form_$side_number|.max_hitpoints
  experience=$stored_non_wraith_form_$side_number|.experience
  name=$stored_non_wraith_form_$side_number|.name
  max_experience=9999
  type=$wraithform_type
  canrecruit=true
  attacks_left=1
  [variables]
    # so that other effects will recognize it
    wraithform=true
    # still your leader with the requisite powers!
    EoHS_special_is_wizard_leader=true
    EoHS_special_immune_to_direct_damage=true
    EoHS_special_ends_damaging_attacks=true
    # Bit of a hack - you can't actually cast spells, but let it display the spellcasting window so that it can tell you that wraithform is the reason you can't cast.
    EoHS_special_can_cast_spells=true
  [/variables]
[/unit]
{VARIABLE_OP new_wraithform.moves multiply $stored_non_wraith_form_$side_number|.moves}
{VARIABLE_OP new_wraithform.moves divide $stored_non_wraith_form_$side_number|.max_moves}
{VARIABLE new_wraithform.advances_to null}
[set_variables]
  name=new_wraithform.advancement
  mode=replace
  [value]
  [/value]
[/set_variables]
[unstore_unit]
  variable=new_wraithform
  text=_ "wraithform"
  red,green,blue=0,0,0
[/unstore_unit]
#enddef

#define devour_soul_INFO_INIT
{BASE_SPELL_STATS devour_soul attacks/scythe.png   necromancy 9   7   1}
#enddef
#define devour_soul_NAME
_"Devour Soul"#enddef
#define devour_soul_DESCRIPTION
_"You instantly kill an adjacent unit - either one of your units,
or an enemy unit with hitpoints no higher than your Necromancy skill.
You are permanently gain half its max hitpoints (and you're healed
for that amount), all its unit abilities, and any attack that is
innate (i.e. not just a weapon the unit holds - admittedly, which
attacks are counted is subjective..)"#enddef
#define devour_soul_AUXILIARY_EVENTS
#enddef
#define devour_soul_CHECK_TARGET
[if]
  [have_unit]
    x=$x1
    y=$y1
    [and]
      x=$caster.x
      y=$caster.y
    [/and]
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You can't devour your own soul."}
  [/then]
[/if]

[if]
  [have_unit]
    x=$x1
    y=$y1
    [filter_wml]
      [status]
        not_living=yes
      [/status]
    [/filter_wml]
    [not]
      race=undead
    [/not]
  [/have_unit]
  [then]
    {CANT_CAST_WITH_MESSAGE _"You can't devour the soul of a non-living, non-undead unit."}
  [/then]
[/if]

[if]
  [have_unit]
    x=$x1
    y=$y1
  [/have_unit]
  [else] # else
    {CANT_CAST_WITH_MESSAGE _"Devour Soul can only be cast on a unit."}
  [/else]
  [then] # then
    [store_unit]
      [filter]
        x=$x1
        y=$y1
      [/filter]
      variable=dsct_checkee
    [/store_unit]
    {IF_VAR dsct_checkee.side not_equals $side_number ([then]
      {IF_VAR dsct_checkee.hitpoints greater_than $necromancy_skill_$side_number|| ([then]
        {CANT_CAST_WITH_MESSAGE _"You can't cast Devour Soul on an enemy unit with hitpoints greater than your Necromancy skill."}
      [/then])}
    [/then])}
  [/then]
[/if]
#enddef
#define OR_DSE_ATTACK_NAME_CONTAINS PART_OF_NAME
[or]
  [variable]
    name=devoured.attack[$dse_i].name
    contains={PART_OF_NAME}
  [/variable]
[/or]
#enddef
#define OR_DSE_ATTACK_NAME_IS PART_OF_NAME
[or]
  [variable]
    name=devoured.attack[$dse_i].name
    equals={PART_OF_NAME}
  [/variable]
[/or]
#enddef
#define devour_soul_EFFECTS
[sound]
  name=dwarf-laugh.wav
[/sound]
[store_unit]
  [filter]
    x=$x1
    y=$y1
  [/filter]
  variable=devoured
[/store_unit]

{VARIABLE_OP devoured.max_hitpoints divide 2}

{VARIABLE_OP caster.hitpoints add $devoured.max_hitpoints}
[unstore_unit]
  variable=caster
  text=$devoured.max_hitpoints
  {COLOR_HEAL}
[/unstore_unit]

{VARIABLE need_to_replace_leadership false}
{FOREACH devoured.abilities.leadership dse_i}
  {IF_VAR devoured.abilities.leadership[$dse_i].id equals leadership ([then]
    # then we are dealing with one of the game's predefined level-specific leadership abilities and we need to replace it.
    {VARIABLE need_to_replace_leadership true}
  [/then])}
{NEXT dse_i}

[object]
  silent=yes
  [filter]
    x=$caster.x
    y=$caster.y
  [/filter]
  [effect]
    apply_to=hitpoints
    increase_total=$devoured.max_hitpoints
  [/effect]
  [effect]
    apply_to=new_ability
    [insert_tag]
      name=abilities
      variable=devoured.abilities
    [/insert_tag]
  [/effect]
[/object]

{IF_VAR need_to_replace_leadership boolean_equals true ([then]
  [object]
    silent=yes
    [filter]
      x=$caster.x
      y=$caster.y
    [/filter]
    [effect]
      apply_to=remove_ability
      [abilities]
        [leadership]
	  id=leadership
	[/leadership]
      [/abilities]
    [/effect]
    [effect]
      apply_to=new_ability
      [abilities]
        {EOHS_LEADERSHIP}
      [/abilities]
    [/effect]
  [/object]
[/then])}

# Hack fix to gaining temporary regen. Almost certainly buggy.
{IF_VAR caster.variables.eohs_regeneration boolean_equals true ([else] # else
  [object]
    silent=yes
    [filter]
      x=$caster.x
      y=$caster.y
    [/filter]
    [effect]
      apply_to=remove_ability
      [abilities]
        [regenerate]
          id=nature_magic_regenerates
        [/regenerate]
      [/abilities]
    [/effect]
  [/object]
[/else])}

{FOREACH devoured.attack dse_i}
  [if]
    [variable]
      name=devoured.attack[$dse_i].name
      equals=ink
    [/variable]
    {OR_DSE_ATTACK_NAME_CONTAINS fangs}
    {OR_DSE_ATTACK_NAME_CONTAINS claws}
    {OR_DSE_ATTACK_NAME_CONTAINS breath}
    {OR_DSE_ATTACK_NAME_CONTAINS touch}
    {OR_DSE_ATTACK_NAME_CONTAINS tentacle}
    {OR_DSE_ATTACK_NAME_CONTAINS tail}
    {OR_DSE_ATTACK_NAME_CONTAINS bite}
    {OR_DSE_ATTACK_NAME_CONTAINS sting}
    {OR_DSE_ATTACK_NAME_CONTAINS pincers}
    {OR_DSE_ATTACK_NAME_CONTAINS bite}
    {OR_DSE_ATTACK_NAME_CONTAINS fist}
    {OR_DSE_ATTACK_NAME_CONTAINS wail}

    {OR_DSE_ATTACK_NAME_IS web}
    {OR_DSE_ATTACK_NAME_IS jaw}
    {OR_DSE_ATTACK_NAME_IS jaws}
    {OR_DSE_ATTACK_NAME_IS "mud glob"}
    {OR_DSE_ATTACK_NAME_IS baneblade}
    {OR_DSE_ATTACK_NAME_IS slam}
    {OR_DSE_ATTACK_NAME_IS crush}
    {OR_DSE_ATTACK_NAME_IS "berserker frenzy"}
    [then]
      {VARIABLE devoured.attack[$dse_i].apply_to new_attack}
      [object]
        silent=yes
        [filter]
          x=$caster.x
          y=$caster.y
        [/filter]
        [insert_tag]
          name=effect
          variable=devoured.attack[$dse_i]
        [/insert_tag]
      [/object]
    [/then]
  [/if]
{NEXT dse_i}

{UPDATE_DUMMY_ATTACK_SPECIALS $caster.x $caster.y}

{EOHS_FULL_KILL caster (x=$devoured.x
y=$devoured.y) true true}
#enddef



#define extra_cast_INFO_INIT
{BASE_SPELL_STATS extra_cast attacks/fist-skeletal.png   necromancy 13   0   0}
{FREELY_CASTABLE extra_cast}
{FIXED_PRICE extra_cast}
#enddef
#define extra_cast_NAME
_"Curse life once more"#enddef
#define extra_cast_DESCRIPTION
_"This spell can only be cast after you have used up your spell or attack.
You spend 15 HP to be able to cast another spell or make another attack.
If you cast this spell when you have 15 or fewer hit points, it kills you."#enddef
#define extra_cast_AUXILIARY_EVENTS
#enddef
#define extra_cast_CHECK_TARGET
[if]
  [have_unit]
    x=$x1
    y=$y1
    [filter_wml]
      attacks_left=0
    [/filter_wml]
  [/have_unit]

  [else] # else
    {CANT_CAST_WITH_MESSAGE _"You can't cast Curse Life Once More before you have used up your attack."}
  [/else]
[/if]
#enddef
#define extra_cast_EFFECTS
{VARIABLE caster.attacks_left 1}
{VARIABLE_OP caster.hitpoints add -15}
[unstore_unit]
  variable=caster
[/unstore_unit]
{IF_VAR caster.hitpoints less_than_equal_to 0 ([then]
  [sound]
    name=dwarf-laugh.wav
  [/sound]
  [sound]
    name=dwarf-laugh.wav
  [/sound]
  [sound]
    name=dwarf-laugh.wav
  [/sound]
  {EOHS_FULL_KILL caster (x,y=$x1,$y1) true false}
[/then]
[else]
  [sound]
    name=lich-hit-2.ogg
  [/sound]
[/else])}
#enddef

