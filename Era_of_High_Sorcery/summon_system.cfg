#textdomain wesnoth-Era_of_High_Sorcery

{~add-ons/Era_of_High_Sorcery/summons.cfg}

#define BASE_SUMMON_STATS SUMMON NAME TYPE IMAGE REALM LEVEL COST
{VARIABLE {SUMMON}_name {NAME}}
{VARIABLE {SUMMON}_type ({TYPE})}
{VARIABLE {SUMMON}_image {IMAGE}}
{VARIABLE {SUMMON}_realm {REALM}}
{VARIABLE {SUMMON}_level {LEVEL}}
{VARIABLE {SUMMON}_base_cost {COST}}
{VARIABLE {SUMMON}_freely_castable false}
{VARIABLE {SUMMON}_fixed_price false}
{VARIABLE {SUMMON}_two false}
#enddef

#define SUMMON_INFO_INIT SUMMON
{{SUMMON}_INFO_INIT}
#enddef

#define SUMMON_TWO SUMMON
{VARIABLE {SUMMON}_two true}
#enddef

#define SUMMON_TERRAIN_RESTRICTION TERRAIN_MOVEMENT_NAME TERRAIN_TYPE MESSAGE
[if]
  [not]
    [variable]
      name=summoned_unit_check.movement_costs.{TERRAIN_MOVEMENT_NAME}
      less_than_equal_to=$summoned_unit_check.max_moves
    [/variable]
    [variable]
      name=summoned_unit_check.movement_costs.{TERRAIN_MOVEMENT_NAME}
      greater_than=0
    [/variable]
  [/not]
  [have_location]
    x=$x1
    y=$y1
    terrain={TERRAIN_TYPE}
  [/have_location]
  [then]
    {CANT_CAST_WITH_MESSAGE {MESSAGE}}
  [/then]
[/if]
#enddef

#define SETUP_SUMMON_INFO SUMMON
{CLEAR_VARIABLE summoned_unit_check}
[unit]
  type=${SUMMON}_type
  side=1
  x=0
  y=0
  to_variable=summoned_unit_check
[/unit]

{VARIABLE {SUMMON}_cost ${SUMMON}_base_cost}
{IF_VAR EoHS_multiply_spell_prices greater_than 0 ([then]
  {VARIABLE_OP {SUMMON}_cost multiply $EoHS_multiply_spell_prices}
[/then])}

{VARIABLE summon_cost_divisor 1}

#{IF_VAR master_summoner_$side_number boolean_equals true ([and]
#  [variable]
#    name={SUMMON}_fixed_price
#    boolean_equals=false
#  [/variable]
#[/and]
#[then]
#  {VARIABLE_OP {SUMMON}_cost       multiply 4}
#  {VARIABLE_OP summon_cost_divisor multiply 5}
#[/then])}

{IF_VAR EoHS_divide_spell_prices greater_than 0 ([then]
  {VARIABLE_OP summon_cost_divisor multiply $EoHS_divide_spell_prices}
[/then])}

{VARIABLE_OP {SUMMON}_cost divide $summon_cost_divisor}

{VARIABLE {SUMMON}_summon_cap_breached false}
{IF_VAR EoHS_summon_level_cap greater_than 0 ([then]
  {VARIABLE {SUMMON}_level_cost $summoned_unit_check.level}
  {VARIABLE_OP {SUMMON}_level_cost multiply 2}
  {IF_VAR {SUMMON}_level_cost equals 0 ([then]
    {VARIABLE {SUMMON}_level_cost 1}
  [/then])}

  {IF_VAR {SUMMON}_level_cost greater_than $summon_levels_allowed ([then]
    {VARIABLE {SUMMON}_summon_cap_breached true}
  [/then])}
  {IF_VAR {SUMMON}_two boolean_equals true ([then]
    {VARIABLE double_level_cost ${SUMMON}_level_cost}
    {VARIABLE_OP double_level_cost add ${SUMMON}_level_cost}
    {IF_VAR double_level_cost greater_than $summon_levels_allowed ([then]
      {VARIABLE {SUMMON}_summon_cap_breached true}
    [/then])}
  [/then])}
[/then])}

{VARIABLE summon_cost ${SUMMON}_cost}
{IF_VAR EoHS_uses_mana_instead_of_gold boolean_equals true ([then]
  {VARIABLE {SUMMON}_cost_string _"$summon_cost| mana"}
[/then]
[else]
  {VARIABLE {SUMMON}_cost_string _"$summon_cost| gold"}
[/else])}
{IF_VAR {SUMMON}_freely_castable boolean_equals true ([then]
  {VARIABLE {SUMMON}_cost_string ${SUMMON}_cost_string|+_", Instant"}
[/then])}

{VARIABLE current_player_knows_{SUMMON} false}
{IF_VAR ${SUMMON}_realm|_skill_$side_number greater_than_equal_to ${SUMMON}_level ([and]
  [not]
    [variable]
      name=EoHS_disallow_unit_creation
      boolean_equals=true
    [/variable]
  [/not]
[/and]
[then]
  {VARIABLE current_player_knows_{SUMMON} true}
  {VARIABLE can_cast true}
  {CLEAR_VARIABLE cant_cast_messages}

  [if]
    [variable]
      name=caster.variables.wraithform
      boolean_equals=true
    [/variable]
    [then]
      {CANT_CAST_WITH_MESSAGE _"You can't cast spells while in wraithform."}
    [/then]
  [/if]

  [if]
    [variable]
      name=caster.variables.rampage
      boolean_equals=true
    [/variable]
    [then]
      {CANT_CAST_WITH_MESSAGE _"You can't cast spells while on a rampage."}
    [/then]
  [/if]

  [if]
    [have_location]
      x=$x1
      y=$y1
      [filter_adjacent_location]
        x=$caster.x
        y=$caster.y
      [/filter_adjacent_location]
    [/have_location]

    [else] # else
      {CANT_CAST_WITH_MESSAGE _"You can only summon units next to your leader."}
    [/else]
  [/if]

  [if]
    [have_unit]
      x=$x1
      y=$y1
    [/have_unit]
    [then]
      {CANT_CAST_WITH_MESSAGE _"You can't summon where there is already a unit."}
    [/then]
  [/if]

  [if]
    {CURRENT_SIDE_HAS_GOLD_OR_MANA_OF_AT_LEAST ${SUMMON}_cost}
    [or]
      [variable]
        name={SUMMON}_cost
	equals=0
      [/variable]
    [/or]
    [else] # else
      {IF_VAR EoHS_uses_mana_instead_of_gold boolean_equals true ([then]
        {CANT_CAST_WITH_MESSAGE _"You don't have enough mana to summon that creature."}
      [/then]
      [else]
        {CANT_CAST_WITH_MESSAGE _"You don't have enough gold to summon that creature."}
      [/else])}
    [/else]
  [/if]

  {IF_VAR caster.attacks_left greater_than_equal_to 1 ([or]
    [variable]
      name={SUMMON}_freely_castable
      boolean_equals=true
    [/variable]
  [/or]
  [or]
    [variable]
      name=master_summoner_$side_number
      boolean_equals=true
    [/variable]
    [variable]
      name=extra_summons_left
      greater_than=0
    [/variable]
  [/or]
  [else] # else
    {CANT_CAST_WITH_MESSAGE _"You can't cast that spell because you don't have any attacks left."}
  [/else])}

  {SUMMON_TERRAIN_RESTRICTION unwalkable Ql,Qlf _"You can't summon that creature into lava."}
  {SUMMON_TERRAIN_RESTRICTION unwalkable Qxu _"You can't summon that creature over a chasm."}
  {SUMMON_TERRAIN_RESTRICTION deep_water Wo _"You can't summon that creature over deep water."}
  {SUMMON_TERRAIN_RESTRICTION mountains Mm,Md,Ms _"You can't summon that creature into mountains."}

  {IF_VAR {SUMMON}_two boolean_equals true ([then]
    [if]
      [not]
        [have_location]
          {IS_REASONABLE_LOCATION}
          [not]
            [filter]
            [/filter]
          [/not]
          [not]
            # HACK - assuming no flying/swimming summon-twos
            terrain=Qlf,Qxu,Ql,Wo
          [/not]
	  [filter_adjacent_location]
            x=$x1
            y=$y1
	  [/filter_adjacent_location]
	  [filter_adjacent_location]
            x=$caster.x
            y=$caster.y
	  [/filter_adjacent_location]
	[/have_location]
      [/not]
      [then]
        {CANT_CAST_WITH_MESSAGE _"There is no viable hex to place the second unit next to the first."}
      [/then]
    [/if]
  [/then])}

  {IF_VAR {SUMMON}_summon_cap_breached boolean_equals true ([then]
    {CANT_CAST_WITH_MESSAGE _"This scenario has a cap on the number of levels of summoned creatures you control;
   casting this summoning spell would exceed the cap."}
  [/then])}

  {VARIABLE current_player_can_cast_{SUMMON} $can_cast}
  {IF_VAR current_player_can_cast_{SUMMON} boolean_equals true ([then]
    {VARIABLE {SUMMON}_opt_string "&${SUMMON}_image|~TC($side_number|,magenta)="+${SUMMON}_name|+" ("+${SUMMON}_cost_string|+")"}
  [/then]
  [else]
    {VARIABLE {SUMMON}_opt_string "&${SUMMON}_image|~TC($side_number|,magenta)=<span color='#FF0000'>"+${SUMMON}_name|+" ("+${SUMMON}_cost_string|+")</span>"}
    [set_variable]
      name=current_player_cant_cast_message_{SUMMON}
      [join]
        variable=cant_cast_messages
        key=message
        separator="
"
      [/join]
    [/set_variable]
  [/else])}
[/then])}
#enddef

#define SUMMON_OPTION SUMMON
[option]
  message=${SUMMON}_opt_string
  [show_if]
    [variable]
      name=current_player_knows_{SUMMON}
      boolean_equals=true
    [/variable]
    [and]
      [variable]
        name=eohs_hide_disallowed_spells_$side_number
        boolean_equals=false
      [/variable]
      [or]
        [variable]
          name=current_player_can_cast_{SUMMON}
          boolean_equals=true
        [/variable]
      [/or]
    [/and]
  [/show_if]
  [command]
    {IF_VAR current_player_can_cast_{SUMMON} boolean_equals true ([else] # else
      [message]
        speaker=narrator
        side_for=$side_number
        message=$current_player_cant_cast_message_{SUMMON}
        image={SPELLCASTING_ICON}
      [/message]
    [/else]
    [then]
      {IF_VAR {SUMMON}_freely_castable boolean_equals false ([then]
	{IF_VAR master_summoner_$side_number boolean_equals true ([and]
          [variable]
            name=extra_summons_left
            greater_than=0
          [/variable]
        [/and]
        [then]
	  {VARIABLE_OP extra_summons_left add -1}
	[/then]
        [else]
          {VARIABLE_OP caster.attacks_left add -1}
	  {VARIABLE_OP extra_summons_left add 1}
        [/else])}
      [/then])}
      {VARIABLE caster.resting no}
      [unstore_unit]
        variable=caster
      [/unstore_unit]

      {MODIFY_GOLD_OR_MANA_OF_CURRENT_SIDE -${SUMMON}_cost}
      [scroll_to]
        x=$x1
        y=$y1
        check_fogged=true
      [/scroll_to]

      {VARIABLE done_summoning false}
      {VARIABLE summons_so_far 0}
      [while]
      [variable]
      name=done_summoning
      equals=false
      [/variable]
      [do]

      {VARIABLE_OP summons_so_far add 1}

      {IF_VAR {SUMMON}_two boolean_equals true ([then]
        {IF_VAR summons_so_far greater_than 1 ([then]
          {VARIABLE done_summoning true}
          # find the second space
          {GET_DIRECTION_TO_ADJACENT_HEX direction_to_first (x,y=$caster.x,$caster.y) (x,y=$x1,$y1)}
          {GET_CLOCKWISE_DIRECTION direction_to_second direction_to_first}
          {GET_OPPOSITE_DIRECTION inverse_direction_to_second direction_to_second}
          [store_locations]
            {IS_REASONABLE_LOCATION}
            [not]
              [filter]
              [/filter]
            [/not]
            [not]
              # hack - assuming no flying summon-twos
              terrain=Qlf,Qxu,Ql
            [/not]
            [filter_adjacent_location]
              adjacent=$inverse_direction_to_second
              x=$caster.x
              y=$caster.y
            [/filter_adjacent_location]
            variable=option_being_right
          [/store_locations]
          {IF_VAR option_being_right.length equals 0 ([then]
            # get the other option - it must be right
            {GET_COUNTERCLOCKWISE_DIRECTION direction_to_second direction_to_first}
            {GET_OPPOSITE_DIRECTION inverse_direction_to_second direction_to_second}
            [store_locations]
              [filter_adjacent_location]
                adjacent=$inverse_direction_to_second
                x=$caster.x
                y=$caster.y
              [/filter_adjacent_location]
              variable=option_being_right
            [/store_locations]
          [/then])}
          {VARIABLE x1 $option_being_right.x}
          {VARIABLE y1 $option_being_right.y}
        [/then])}
      [/then]
      [else]
        {VARIABLE done_summoning true}
      [/else])}

      {CLEAR_VARIABLE eohs_summoned_unit}
      [set_variables]
        name=eohs_summoned_unit_tag
      [value]
        side=$side_number
	type=${SUMMON}_type
	x=$x1
	y=$y1
	moves=0
	attacks_left=0
#	overlays="lobby/status-obs-f.png~CROP(3,4,9,9)"
        overlays=misc/loyal-icon.png
	[variables]
	  summoned=true
          xp_taxed_to_leader=0
          experience_gained=0
          price_originally_summoned_for=${SUMMON}_cost
	  summon_level_cost=${SUMMON}_level_cost
	[/variables]
	to_variable=eohs_summoned_unit
      [/value]
      [/set_variables]
      #IF_VAR EoHS_summons_are_loyal boolean_equals true ([then]
        [set_variables]
	  name=eohs_summoned_unit_tag.modifications
          mode=append
	  [value]
	    {TRAIT_LOYAL}
	  [/value]
        [/set_variables]
      #[/then])}
      [insert_tag]
        variable=eohs_summoned_unit_tag
        name=unit
      [/insert_tag]
      [unstore_unit]
	variable=eohs_summoned_unit
      [/unstore_unit]
      [capture_village]
        x=$x1
	y=$y1
	side=$side_number
      [/capture_village]

      [fire_event]
        name=prerecruit
	[primary_unit]
	  x=$x1
	  y=$y1
	[/primary_unit]
      [/fire_event]

      [animate_unit]
        [filter]
	  x=$x1
	  y=$y1
	[/filter]
	flag=recruited
      [/animate_unit]

      [fire_event]
        name=recruit
	[primary_unit]
	  x=$x1
	  y=$y1
	[/primary_unit]
      [/fire_event]
      
      [redraw]
        side=$side_number
      [/redraw]

      [/do]
      [/while]
    [/then])}
  [/command]
[/option]
#enddef

#define SETUP_ALL_SUMMONS_INFO
{IF_VAR EoHS_summon_level_cap greater_than 0 ([then]
  [store_unit]
    [filter]
      side=$side_number
      [filter_wml]
        [variables]
	  summoned=true
	[/variables]
      [/filter_wml]
    [/filter]
    variable=summoned_units
  [/store_unit]
  {VARIABLE summon_total_level_cost 0}
  {FOREACH summoned_units ehs_sas_i}
    {VARIABLE_OP summon_total_level_cost add $summoned_units[$ehs_sas_i].variables.summon_level_cost}
  {NEXT ehs_sas_i}
  {VARIABLE summon_levels_allowed $EoHS_summon_level_cap}
  {VARIABLE_OP summon_levels_allowed add -$summon_total_level_cost}
[/then])}
 
  {APPLY_FOR_ALL_SUMMONS SETUP_SUMMON_INFO}
#enddef

#define SPLIT_XP_TO_LEADER VAR AMOUNT
[store_unit]
  [filter]
    side=${VAR}.side
    {IS_WIZARD_LEADER}
  [/filter]
  variable=leader
[/store_unit]
{IF_VAR leader.length greater_than 0 ([then]
  {VARIABLE_OP {VAR}.variables.experience_gained add {AMOUNT}}
  {VARIABLE xp_to_give ${VAR}.variables.experience_gained}
  {VARIABLE_OP xp_to_give add -${VAR}.variables.xp_taxed_to_leader}
  {VARIABLE_OP xp_to_give divide 2}
  {VARIABLE_OP {VAR}.experience add -$xp_to_give}
  {VARIABLE_OP {VAR}.variables.experience_gained add -$xp_to_give}
  {VARIABLE_OP leader.experience add $xp_to_give}
  {VARIABLE_OP {VAR}.variables.xp_taxed_to_leader add $xp_to_give}
  [unstore_unit]
    variable={VAR}
  [/unstore_unit]
  [unstore_unit]
    variable=leader
  [/unstore_unit]
[/then])}
#enddef

#define SPLITS_XP_WITH_LEADER
#[not] # mainly to avoid confusion between recruited and summoned units of these types
#  type=Walking Corpse,Soulless,Vampire Bat,Blood Bat,Dread Bat,Skeleton,Deathblade,Revenant,Draug,Skeleton Archer,Bone Shooter,Banebow
#[/not]
[filter_wml]
  [variables]
    summoned=true
  [/variables]
[/filter_wml]
#enddef

#define USE_SUMMON_SYSTEM
[event]
name=prestart
  {APPLY_FOR_ALL_SUMMONS SUMMON_INFO_INIT}

  # Allow unsummoning, if allowed
  [set_menu_item]
    id=eohs_unsummon
    image=misc/reloaded.png
    description=_"Unsummon this creature"
    [show_if]
      [variable]
        name=EoHS_allow_unsummoning
	boolean_equals=true
      [/variable]
    [/show_if]
    [filter_location]
      [filter]
        side=$side_number
        [filter_wml]
          [variables]
	    summoned=true
          [/variables]
	[/filter_wml]
      [/filter]
    [/filter_location]
    
    [command]
      [kill]
        x=$x1
	y=$y1
	animate=yes
	fire_event=no
      [/kill]
    [/command]
  [/set_menu_item]
[/event]

# Give the leader half the summons' experience.
[event]
name=attack end
first_time_only=no
[filter]
  {SPLITS_XP_WITH_LEADER}
[/filter]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=splitter
  [/store_unit]
  [store_unit]
    [filter]
      x=$x2
      y=$y2
    [/filter]
    variable=other
  [/store_unit]
  {IF_VAR splitter.hitpoints greater_than 0 ([then] # Because dead units don't actually gain combat XP
    {IF_VAR splitter.side not_equals $other.side ([then] # Hack - because reanimated units don't actually gain experience from fighting your leader
      {SPLIT_XP_TO_LEADER splitter $other.level}
    [/then])}
  [/then])}
[/event]

[event]
name=attack end
first_time_only=no
[filter_second]
  {SPLITS_XP_WITH_LEADER}
[/filter_second]
  [store_unit]
    [filter]
      x=$x2
      y=$y2
    [/filter]
    variable=splitter
  [/store_unit]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=other
  [/store_unit]
  {IF_VAR splitter.hitpoints greater_than 0 ([then] # Because dead units don't actually gain combat XP
    {IF_VAR splitter.side not_equals $other.side ([then] # Hack - because reanimated units don't actually gain experience from fighting your leader
      {SPLIT_XP_TO_LEADER splitter $other.level}
    [/then])}
  [/then])}
[/event]

[event]
name=die
first_time_only=no
[filter_second]
  {SPLITS_XP_WITH_LEADER}
[/filter_second]
  [store_unit]
    [filter]
      x=$x2
      y=$y2
    [/filter]
    variable=splitter
  [/store_unit]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=victim
  [/store_unit]
  {IF_VAR splitter.side not_equals $victim.side ([then] # Hack - because absorbed bats etc. don't actually get XP from "killing" "themselves"
    # Multiply by seven because this overlaps with attack-end
    {VARIABLE_OP victim.level multiply 7}
    {IF_VAR victim.level equals 0 ([then]
      {VARIABLE victim.level 4}
    [/then])}
    {SPLIT_XP_TO_LEADER splitter $victim.level}
  [/then])}
[/event]

# The advancement for Chocobones.
[event]
name=recruit
first_time_only=no
[filter]
  type=Chocobone
  [filter_wml]
    [variables]
      summoned=true
    [/variables]
  [/filter_wml]
[/filter]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=chocobone
  [/store_unit]
  {VARIABLE_OP chocobone.max_experience divide 2}
  {VARIABLE chocobone.advances_to "Death Knight"}
  [unstore_unit]
    variable=chocobone
  [/unstore_unit]
[/event]

[event]
name=advance
[filter]
  type=Chocobone
  [filter_wml]
    [variables]
      summoned=true
    [/variables]
  [/filter_wml]
[/filter]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=chocobone
  [/store_unit]
  {VARIABLE chocobone.variables.is_advancing_chocobone true}
  [unstore_unit]
    variable=chocobone
  [/unstore_unit]
[/event]

[event]
name=post advance
[filter]
  [filter_wml]
    [variables]
      is_advancing_chocobone=true
    [/variables]
  [/filter_wml]
[/filter]
  [store_unit]
    [filter]
      x=$x1
      y=$y1
    [/filter]
    variable=chocobone
  [/store_unit]
  {VARIABLE chocobone.variables.is_advancing_chocobone false}
  [unstore_unit]
    variable=chocobone
  [/unstore_unit]
  [object]
    silent=yes
    [filter]
      x=$x1
      y=$y1
    [/filter]
    [effect]
      apply_to=movement
      increase=4
    [/effect]
    [effect]
      apply_to=remove_ability
      [abilities]
        {ABILITY_LEADERSHIP_LEVEL_3}
      [/abilities]
    [/effect]
    [effect]
      apply_to=new_ability
      [abilities]
        {ABILITY_SUBMERGE}
      [/abilities]
    [/effect]
    [effect]
      apply_to=attack
      name="battle axe"
      set_name=halberd
      set_description=_"halberd"
      set_icon=attacks/halberd.png
      increase_attacks=-1
    [/effect]
    [effect]
      apply_to=new_attack
      name=halberd
      description=_"halberd"
      icon=attacks/halberd.png
      type=pierce
      range=melee
      [specials]
          {WEAPON_SPECIAL_CHARGE}
      [/specials]
      damage=14
      number=2
    [/effect]
  [/object]
[/event]
#enddef

